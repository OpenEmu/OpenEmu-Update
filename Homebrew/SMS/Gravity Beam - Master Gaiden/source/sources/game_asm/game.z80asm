; SEGA MASTER SYSTEM GAME THING
; (c) 2013 Mathew Carr
; Started 16th January 2013.

.include "segamastersystem.z80asm"

.include "audio.z80asm"
.include "maths.z80asm"

.include "huffman_archives\huffman_archive_1.z80asm"

;==============================================================
; SDSC tag and SMS rom header

; This stuff is interpreted by WLA-DX and used to produce a uniformly parsable
; ROM header that SDSC tools can use to navigate this homebrew ROM should it
; find its way into some bloke's directory o' ROMS.

; Version, Title, Description, Author
.sdsctag 1.01,"Gravity Beam: Master Gaiden",WLA_TIME,"Matt Carr mattcarr@gmail.com"
; Tested on a PAL Master System II
;==============================================================

.macro VBLANK_TOKEN_INIT
    xor    a
    ld     (var_VBlankTokenReady),a ; Eat token by setting it to zero
.endm

.macro SetVDPAddress_UNSAFE
    ld     a,l
    out    (PORT_VDPControl),a
    ld     a,h
    out    (PORT_VDPControl),a
.endm

.macro SetVDPAddress_bc_UNSAFE
    ld     a,c
    out    (PORT_VDPControl),a
    ld     a,b                                                                                                       
    out    (PORT_VDPControl),a
.endm

.macro SetVDPAddress_de_UNSAFE
    ld     a,e
    out    (PORT_VDPControl),a
    ld     a,d
    out    (PORT_VDPControl),a
.endm

.macro SetVDPAddress_af_prime
    ex     af,af'
    ld     a,l
    out    (PORT_VDPControl),a
    ld     a,h
    out    (PORT_VDPControl),a
    ex     af,af'
.endm

.macro ABS_HL
    bit    7,h
    jp     z,ABS_HL\@
    push   af
    push   de
    ex     de,hl
    ld     hl,0
    xor    a
    sbc    hl,de
    pop    de
    pop    af
ABS_HL\@:
.endm

.define GAME_WORLD_X_SIZE       1024
.define GAME_WORLD_X_MEGATILES  (GAME_WORLD_X_SIZE/16)
.define GAME_WORLD_Y_SIZE        768
.define GAME_WORLD_Y_MEGATILES  (GAME_WORLD_Y_SIZE/16)

.define VISIBLE_DISPLAY_X_SIZE   248
.define VISIBLE_DISPLAY_Y_SIZE   192

.bank 0                               ; Within the ROM:
.section "vblank" free                ; exists at wherever the linker can put it!
vblank_wait:
    halt                              ; Pause processor until interrupt occurs.

    ld     a,(var_VBlankTokenReady)   ; Halt again unless the VBlank token is ready.
    or     a                          ; Loading does not affect the condition bits. This is like a faster cp 0.
    jp     z,vblank_wait              ; Loop if var_VBlankTokenReady is zero.

    VBLANK_TOKEN_INIT                 ; Eat token by setting it to zero
    ret                               ; Fits nicely in the gap between the ISR and NMI handlers!!
.ends

.bank 0
.section "waste_t_states" free ; Might be compiled out if I get this damn thing working right!
waste_39_t_states:
    nop
waste_35_t_states:
    nop
waste_31_t_states:
    nop
waste_27_t_states:
    ret
.ends

.bank 0
.section "maincode" free
;==============================================================
; Main program
;==============================================================
main:
    call   systems_init
    ; Put a different _init routine here to skip to that screen     jp     game_init
    jp     plot_1_init

;==============================================================

systems_init:
    call   controller_init
    call   audio_init

    ; Full volume
    xor    a
    ld     (music_global_player_attenuation),a

    call   vdp_set_registers_screen_mode_ingame

    ld     hl,isr_vblank_only
    ld     (var_isr_vector),hl            ; Store the location of VBlankRoutine into RAM at VBlankRoutine_vector.

    call   vram_clear_all

    VBLANK_TOKEN_INIT

    ei

    ret

game_init:          
    ; Put some extra frames here so that the sound effects can finish.
    ; I'm thinking off the biddly-beep that transitions from the main menu
    ; and the game over screen into the ingame countin sequence.
    ; I'm sure this 1/3 of a second will eat up people, but it's important.
    ld     b,15

-:  call   vblank_wait
    push   bc
       call   music_tick
       call   instruments_tick
       call   percussion_tick
       call   sound_tick                      
    pop    bc
    djnz   -

    call   music_stop

    ei

    ; Actual game initialisation starts here:

    call   game_state_init

    call   vblank_wait

    di

    call   vdp_registers_blank_screen
    call   game_vram_init

    call   vdp_set_registers_screen_mode_ingame

    ld     hl,isr_vblank_only
    ld     (var_isr_vector),hl            ; Store the location of VBlankRoutine into RAM at VBlankRoutine_vector.

    call   ingame_set_scroll_registers
    call   vdp_registers_unblank_screen

    ei

    call   vblank_wait

    di

    call   vdp_registers_blank_screen
    call   ingame_graphics_draw_initial_screen_tiles
    call   vdp_registers_unblank_screen

    ei

    call   vblank_wait

    di

    ; Palette to black.
    ld     hl,palette_data_ingame
    ld     e,3
    call   graphics_copy_faded_palettes_to_black
    ei

    call   vblank_wait
    call   vdp_registers_unblank_screen

    ; Full volume
    xor    a
    ld     (music_global_player_attenuation),a

    ld     hl,music_gravity_beam_panic
    call   music_select_song
    call   music_resume

; Fade in the screen from black
ingame_fade_in_frame:
    ; This is a 'chibi' version of the main game loop.
    ; We miss out all the logic, and just have the rendering stuff.

    call   vblank_wait
    ; A new frame has begun!

    ; Disable the interrupts to allow for uninterrupted VDP access.
    ; Not that there ARE any interrupts that should happen here (vblank twice that rapidly? probably not.)
    di

    call   vdp_registers_blank_screen
    call   ingame_set_scroll_registers

;    call   ingame_graphics_draw_new_rows_columns
    call   ingame_graphics_place_greenwing_sprite
;    call   ingame_graphics_set_carrybox_sprite_palette       ; Notice that we're not drawing the crate as we know it's offscreen.
;    call   ingame_graphics_place_carrybox_sprite
;    call   ingame_graphics_place_linkage_sprites
    call   ingame_graphics_place_bombled_sprites
    call   ingame_graphics_copy_greenwing_frame_to_vram
    call   vdp_registers_unblank_screen       
    
    ; Fade in from black as counte rgoes from 0 to 31.
    ld     a,(game.anim_frame_counter)
    srl    a
    srl    a
    srl    a
    ld     b,a
    ld     a,3
    sub    b
    ld     e,a
    ld     hl,palette_data_ingame
    call   graphics_copy_faded_palettes_to_black

    ei

    ; After messing around with tricky fractional maths, update the pixel
    ; cached versions to allow the camera and sprite stuff to work
    call   ingame_update_player_and_box_position_pixels_from_fixed_point

    ; Attempt to move the camera to focus the screen on the player
;    call   ingame_camera_logic_safely_track_player
    ; Update the scroll registers based on the camera's motion.
;    call   ingame_camera_logic_displace_scroll_registers

    ; This is all non-graphics stuff down here. So it's okay
    ; if we have a super long graphics-mangling frame, and then
    ; mess about with the controller and audio chip.

    call   controller_update

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick
    
    ; Advance the animation counter.
    ld     a,(game.anim_frame_counter)
    inc    a
    ld     (game.anim_frame_counter),a
    cp     32
    jp     nz,ingame_fade_in_frame

; Count in numbers.
ingame_count_in_init:
    ld     a,149
    ld     (game.anim_frame_counter),a

ingame_count_in_frame:

    call   vblank_wait
    ; A new frame has begun!

    ; Disable the interrupts to allow for uninterrupted VDP access.
    ; Not that there ARE any interrupts that should happen here (vblank twice that rapidly? probably not.)
    di

    call   vdp_registers_blank_screen

    ; Determine which count in number we're going to display and place it in B. Use repeated subtraction to divide game.anim_frame_counter by 50.
    ld     b,0
    ld     a,(game.anim_frame_counter)
-:  sub    50                                                   ; I thought I had a define for FRAMES_PER_SECOND, but I don't!
    jp     c,ingame_count_in_frame_50_subtractions_complete
    inc    b
    jp     -
ingame_count_in_frame_50_subtractions_complete:
    ; b contains the frame to show.
    ld     a,b
    add    a,a
    add    a,a                                                  ; Multiply by 4.
    add    a,21                                                 ; Add on an offset into the sprite pattern VRAM.
    ld     b,a
    ; B contains the index of the first sprite.
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+10       ; Place this into the appropriate memory location for Sprite 10 (it's a bombled colon, so it'll disappear ingame!)
    SetVDPAddress_de_UNSAFE
.equ INGAME_COUNT_IN_SPRITE_LEFT_X = 123
.equ INGAME_COUNT_IN_SPRITE_TOP_Y  =  63
    ld     a,INGAME_COUNT_IN_SPRITE_TOP_Y
    out    (PORT_VDPData),a                                     ; Write the Y coordinate.
    nop
    out    (PORT_VDPData),a                                     ; Write the Y coordinate.
    ld     a,INGAME_COUNT_IN_SPRITE_TOP_Y+8
    out    (PORT_VDPData),a                                     ; Write the Y coordinate.
    nop
    out    (PORT_VDPData),a                                     ; Write the Y coordinate.
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+10*2    ; Place this into the appropriate memory location for Sprite 10 (it's a bombled colon, so it'll disappear ingame!)
    SetVDPAddress_de_UNSAFE
    ld     a,INGAME_COUNT_IN_SPRITE_LEFT_X
    out    (PORT_VDPData),a                                     ; Write the X coordinate.
    ld     a,b
    inc    b
    out    (PORT_VDPData),a                                     ; Write the tile number from the map
    ld     a,INGAME_COUNT_IN_SPRITE_LEFT_X+8
    out    (PORT_VDPData),a                                     ; Write the X coordinate.
    ld     a,b
    inc    b
    out    (PORT_VDPData),a                                     ; Write the tile number from the map
    ld     a,INGAME_COUNT_IN_SPRITE_LEFT_X
    out    (PORT_VDPData),a                                     ; Write the X coordinate.
    ld     a,b
    inc    b
    out    (PORT_VDPData),a                                     ; Write the tile number from the map
    ld     a,INGAME_COUNT_IN_SPRITE_LEFT_X+8
    out    (PORT_VDPData),a                                     ; Write the X coordinate.
    ld     a,b
    out    (PORT_VDPData),a                                     ; Write the tile number from the map

    call   vdp_registers_unblank_screen


    ei

    call   controller_update

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick                  

    ; Pause works here.
    ld     a,(var_ControllerStatus.1.StatusHit)
    bit    CONTROLLER_BIT_PAUSE,a
    jp     z,+
    ld     a,(game.game_paused)
    xor    1
    ld     (game.game_paused),a
+:

    ; Do not advance counter if paused.
    ld     a,(game.game_paused)
    and    a
    jp     nz,ingame_count_in_frame

    ; Advance the animation counter.
    ld     a,(game.anim_frame_counter)
    dec    a
    ld     (game.anim_frame_counter),a
    jp     nz,ingame_count_in_frame
    
ingame_starts_now:

ingame_frame:
    call   vblank_wait
    ; A new frame has begun!

    ; Disable the interrupts to allow for uninterrupted VDP access.
    ; Not that there ARE any interrupts that should happen here (vblank twice that rapidly? probably not.)
    di

    call   vdp_registers_blank_screen
    call   ingame_set_scroll_registers
    call   ingame_graphics_draw_new_rows
    call   ingame_graphics_set_carrybox_sprite_palette
    call   ingame_graphics_place_greenwing_sprite
    call   ingame_graphics_place_carrybox_sprite
    call   ingame_graphics_place_linkage_sprites
    call   ingame_graphics_place_bombled_sprites
    call   ingame_graphics_copy_greenwing_frame_to_vram
    call   vdp_registers_unblank_screen
    call   ingame_graphics_draw_new_columns

    ei

    ; After drawing in the new columns, we update the 'old' registers.
    ld     hl,(game.camera_x)
    ld     (game.camera_old_x),hl
    ld     hl,(game.camera_y)
    ld     (game.camera_old_y),hl

    ; Do not advance if paused.
    ld     a,(game.game_paused)
    and    a
    jp     nz,ingame_paused_skip_game_simulation

    ; Decay the velocities of the player and the box.
    ld     hl,(game.player_velocity_x)
    call   ingame_object_velocity_decay
    ld     (game.player_velocity_x),hl
    ld     hl,(game.player_velocity_y)
    call   ingame_object_velocity_decay
    ld     (game.player_velocity_y),hl
    ld     hl,(game.box_velocity_x)
    call   ingame_object_velocity_decay
    ld     (game.box_velocity_x),hl
    ld     hl,(game.box_velocity_y)
    call   ingame_object_velocity_decay
    ld     (game.box_velocity_y),hl

.endasm
    ; Left and right on controller 2 debug the ship.
    ld     a,(var_ControllerStatus.2.StatusCurrent)
    bit    CONTROLLER_BIT_LEFT,a
    jp     z,+
    ld     hl,(game.player_position_x)
    ld     de,-20
    add    hl,de
    ld     (game.player_position_x),hl
+:  ld     a,(var_ControllerStatus.2.StatusCurrent)
    bit    CONTROLLER_BIT_RIGHT,a
    jp     z,+
    ld     hl,(game.player_position_x)
    ld     de,20
    add    hl,de
    ld     (game.player_position_x),hl
+:  ld     a,(var_ControllerStatus.2.StatusCurrent)
    bit    CONTROLLER_BIT_UP,a
    jp     z,+
    ld     hl,(game.player_position_y)
    ld     de,-20
    add    hl,de
    ld     (game.player_position_y),hl
+:  ld     a,(var_ControllerStatus.2.StatusCurrent)
    bit    CONTROLLER_BIT_DOWN,a
    jp     z,+
    ld     hl,(game.player_position_y)
    ld     de,20
    add    hl,de
    ld     (game.player_position_y),hl
+:
.asm

    ; Left and right on controller 1 rotate the ship.
.define PLAYER_ROTATION_SPEED 4

    ld     a,(var_ControllerStatus.1.StatusCurrent)
    bit    CONTROLLER_BIT_LEFT,a
    jp     z,+
    ld     a,(game.player_orientation)
    sub    PLAYER_ROTATION_SPEED
    ld     (game.player_orientation),a
+:
    ld     a,(var_ControllerStatus.1.StatusCurrent)
    bit    CONTROLLER_BIT_RIGHT,a
    jp     z,+
    ld     a,(game.player_orientation)
    add    a,PLAYER_ROTATION_SPEED
    ld     (game.player_orientation),a
+:
    ; Transform player orientation 0-255 into sprite frame 0-15.
    ld     a,(game.player_orientation)
    add    a,8                                                     ; Add on a bit so that sprite frame 0 covers a V shaped wedge of angles above the player.
    rrca
    rrca
    rrca
    rrca
    and    $F
    ld     (game.player_sprite_frame),a

    ; (by default) Button 2 (on the right) activates thrust:
    ld     a,(var_ControllerStatus.1.StatusCurrent)
    ld     b,a
    ld     a,(game_persistent.thrust_button_mask)
    and    b
    jp     z,ingame_player_control_thrust_button_idle

    ld     a,(game.player_sprite_frame)
    or     16                                                      ; player_sprite_frame |= 16 when thrusting
    ld     (game.player_sprite_frame),a

    ld     a,(game.player_orientation)
    and    %11111110                                               ; Discard least significant bit to get offset into array of words.
    ld     d,0
    ld     e,a                                                     ; Construct 16 bit version of orientation in BC

    ld     hl,thrust_sine_table
    add    hl,de                                                   ; hl = &thrust_sine_table[orientation]
    ld     c,(hl)
    inc    hl
    ld     b,(hl)                                                  ; DE = thrust_sine_table[orientation] 16 bit signed
    ld     hl,(game.player_velocity_x)
    add    hl,bc
    ld     (game.player_velocity_x),hl

    add    a,-64                                                   ; Add -64 (and implicitly AND 255) to get the index into
    ld     e,a                                                     ;   the sine array because we really want cosine instead
    ld     hl,thrust_sine_table                                    ; Location of the cosine table
    add    hl,de                                                   ; hl = &thrust_cosine_table[orientation]
    ld     c,(hl)
    inc    hl
    ld     b,(hl)                                                  ; DE = thrust_cosine_table[orientation] 16 bit signed
    ld     hl,(game.player_velocity_y)
    add    hl,bc
    ld     (game.player_velocity_y),hl
ingame_player_control_thrust_button_idle:

    ; (by default) Button 1 (on the left) activates the titular Gravity Beam:
    ; Or deactivates as the case may be:
    ld     a,(var_ControllerStatus.1.StatusHit)
    ld     b,a
    ld     a,(game_persistent.beam_button_mask)
    and    b
    jp     z,ingame_player_control_gravity_beam_button_idle
    ld     a,(game.player_link_established)
    cp     0
    jp     nz,ingame_player_control_gravity_beam_disengage
    ; The beam is currently off and we want to try and turn it on.
    ; Do a range check, simple rectangular.
.define INGAME_GRAVITY_BEAM_ENGAGEMENT_RANGE_X_PIXELS 45 ; Either side of the ship.
.define INGAME_GRAVITY_BEAM_ENGAGEMENT_RANGE_Y_PIXELS 50 ; Either side of the ship.
    ld     hl,(game.player_position_x_pixels)
    ld     de,INGAME_GRAVITY_BEAM_ENGAGEMENT_RANGE_X_PIXELS
    add    hl,de                                                   ; HL = player+range
    ld     de,(game.box_position_x_pixels)
    xor    a                                                       ; Clear carry before subtraction
    sbc    hl,de
    jp     m,ingame_player_control_gravity_beam_engagement_out_of_range
    ld     hl,(game.player_position_x_pixels)
    ld     de,-INGAME_GRAVITY_BEAM_ENGAGEMENT_RANGE_X_PIXELS
    add    hl,de                                                   ; HL = player-range
    ld     de,(game.box_position_x_pixels)
    xor    a                                                       ; Clear carry before subtraction
    sbc    hl,de
    jp     p,ingame_player_control_gravity_beam_engagement_out_of_range ; Negative means that the box is floating to the left of the ship.
    ; The box is in horizontal range:
    ld     hl,(game.player_position_y_pixels)
    ld     de,INGAME_GRAVITY_BEAM_ENGAGEMENT_RANGE_Y_PIXELS
    add    hl,de                                                   ; HL = player+range
    ld     de,(game.box_position_y_pixels)
    xor    a                                                       ; Clear carry before subtraction
    sbc    hl,de
    jp     m,ingame_player_control_gravity_beam_engagement_out_of_range
    ld     hl,(game.player_position_y_pixels)
    ld     de,-INGAME_GRAVITY_BEAM_ENGAGEMENT_RANGE_Y_PIXELS
    add    hl,de                                                   ; HL = player-range
    ld     de,(game.box_position_y_pixels)
    xor    a                                                       ; Clear carry before subtraction
    sbc    hl,de
    jp     p,ingame_player_control_gravity_beam_engagement_out_of_range ; Negative means that the box is floating to the top of the ship.
    ld     a,1
    ld     (game.player_link_established),a                        ; Set the link established variable
    ; Play the panic theme...
;    ld     hl,music_gravity_beam_panic
;    call   music_select_song
;    call   music_resume
    jp     ingame_player_control_gravity_beam_button_handling_complete
    ; Alternatively: the beam is on and we want to turn it off.
ingame_player_control_gravity_beam_disengage:
    xor    a
    ld     (game.player_link_established),a                        ; Simply set the link established variable to off.
    ; Play the brels theme...
;    ld     hl,music_gravity_beam_panic
;    call   music_select_song
;    call   music_resume
    jp     ingame_player_control_gravity_beam_button_handling_complete

ingame_player_control_gravity_beam_engagement_out_of_range:
    ; Use my neat 'boousssh' sound effect to register a failed beam engagement attempt
    ld     c,0
    call   sound_force

ingame_player_control_gravity_beam_button_handling_complete:
ingame_player_control_gravity_beam_button_idle:

    ; Calculate the forces on the player and box due to the gravity beam
    call   ingame_forces_calculation

.define INGAME_GRAVITY_CONTRIBUTION_PLAYER 4
.define INGAME_GRAVITY_CONTRIBUTION_BOX    4

    ; Apply player gravity and spring force
    ld     hl,(game.player_velocity_y)
    ld     de,INGAME_GRAVITY_CONTRIBUTION_PLAYER
    add    hl,de
    ld     de,(game.ingame_forces_calculation_vdy)
    add    hl,de                                                   ; Adding multiples of the base vdx value allows us to simulate the ship and box having different mass.
    ld     (game.player_velocity_y),hl
    ld     hl,(game.player_velocity_x)
    ld     de,(game.ingame_forces_calculation_vdx)
    add    hl,de
    ld     (game.player_velocity_x),hl

    ; Calculate player's new position from velocity and push it to the stack.
    ld     de,(game.player_velocity_x)                             ; Converting velocity 1.7.8 from to position in 12.4
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    ld     hl,(game.player_position_x)
    add    hl,de
    push   hl                                                      ; Potential X position in HL
    ld     c,h                                                     ; Store the high byte in C
    ld     de,(game.player_velocity_y)
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    ld     hl,(game.player_position_y)
    add    hl,de
    bit    7,h
    jp     nz,ingame_player_collides_with_top_border               ; Trying to go outside the level, huh?
    push   hl                                                      ; Potential Y position in HL
    ; Now we have the potential position for the X and Y coords. We need to see if that's a blocking megatile.
    ; Player position is in 12.4, which means that the high byte contains the number of the megatile. ;D
    ; Construct pointer to megatile at these coords.
    ld     l,h
    ld     h,0                                                     ; HL contains 16-bit y coordinate.
    add    hl,hl                                                   ; HL =  2*y
    add    hl,hl                                                   ; HL =  4*y
    add    hl,hl                                                   ; HL =  8*y
    add    hl,hl                                                   ; HL = 16*y
    add    hl,hl                                                   ; HL = 32*y
    add    hl,hl                                                   ; HL = 64*y
    ld     b,0                                                     ; BC contains 16-bit x coordinate.
    add    hl,bc                                                   ; Final megatile number is in HL
    ld     bc,game.megatiles_array_decompressed
    add    hl,bc
    ld     a,(hl)                                                  ; We have the final megatile number in A.
    ; Colliding megatiles are below this constant value
    cp     15
    jp     p,ingame_player_collision_registers_a_hit
    ; No collision. We're good to update the position.
    pop    hl
    ld     (game.player_position_y),hl
    pop    hl
    ld     (game.player_position_x),hl
    jp     ingame_player_collision_check_complete                  ; We're free to do other stuff
ingame_player_collision_registers_a_hit:
    pop    hl                                                      ; Discard calculated position.
ingame_player_collides_with_top_border:
    pop    hl
    ld     hl,0                                                    ; Zero velocity.
    ld     (game.player_velocity_x),hl
    ld     (game.player_velocity_y),hl
ingame_player_collision_check_complete:

    ; Apply box gravity and spring force
    ld     hl,(game.box_velocity_y)
    ld     de,INGAME_GRAVITY_CONTRIBUTION_BOX
    add    hl,de
    ld     de,(game.ingame_forces_calculation_vdy)
    xor    a                                                       ; Clear carry before sbc.
    sbc    hl,de
    ld     (game.box_velocity_y),hl
    ld     hl,(game.box_velocity_x)
    ld     de,(game.ingame_forces_calculation_vdx)
    xor    a
    sbc    hl,de
    ld     (game.box_velocity_x),hl

    ; Calculate box's new position from velocity and push it to the stack.
    ld     de,(game.box_velocity_x)
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    ld     hl,(game.box_position_x)
    add    hl,de
    push   hl                                                      ; Potential X position in HL
    ld     c,h                                                     ; Store the high byte in C
    ld     de,(game.box_velocity_y)
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    ld     hl,(game.box_position_y)
    add    hl,de
    bit    7,h
    jp     nz,ingame_box_collides_with_top_border                  ; Trying to go outside the level, huh?
    push   hl                                                      ; Potential Y position in HL
    ; Now we have the potential position for the X and Y coords. We need to see if that's a blocking megatile.
    ; box position is in 12.4, which means that the high byte contains the number of the megatile. ;D
    ; Construct pointer to megatile at these coords.
       ; I'm going to sneak in a couple of pixel shift, so the box's collision is actually a little higher than it really is
       ; so that the box will rest on the floor properly. It's cheating, but shut yer face, mate. Notice that we can mess around
       ; with the Y position at this point because we've pushed it already. It's the pushed version that gets written if the
       ; collision check indicates the move is acceptable.
       ld     de,-4*16
       add    hl,de
    ld     l,h
    ld     h,0                                                     ; HL contains 16-bit y coordinate.
    add    hl,hl                                                   ; HL =  2*y
    add    hl,hl                                                   ; HL =  4*y
    add    hl,hl                                                   ; HL =  8*y
    add    hl,hl                                                   ; HL = 16*y
    add    hl,hl                                                   ; HL = 32*y
    add    hl,hl                                                   ; HL = 64*y
    ld     b,0                                                     ; BC contains 16-bit x coordinate.
    add    hl,bc                                                   ; Final megatile number is in HL
    ld     bc,game.megatiles_array_decompressed
    add    hl,bc
    ld     a,(hl)                                                  ; We have the final megatile number in A.
    ; Colliding megatiles are below this constant value
    cp     15
    jp     p,ingame_box_collision_registers_a_hit
    ; No collision. We're good to update the position.
    pop    hl
    ld     (game.box_position_y),hl
    pop    hl
    ld     (game.box_position_x),hl
    jp     ingame_box_collision_check_complete                     ; We're free to do other stuff
ingame_box_collision_registers_a_hit:
    pop    hl                                                      ; Discard calculated position.
ingame_box_collides_with_top_border:
    pop    hl                                                      ; Stack is now balanced. Calculated new position has been obliterated.
    ld     hl,(game.box_velocity_x)
    ABS_HL
    ex     de,hl
    ld     b,d
    ld     c,e
    call   multiply_dehl_equals_bc_times_de                        ; DEHL = vx^2 in 16.16 velocity squared units...
    ld     l,h
    ld     h,e                                                     ; I'm going to discard 8 bits of precision here. HL = vx^2 in 8.8 vsquared units.
    push   hl
    ld     hl,(game.box_velocity_y)
    ABS_HL
    ex     de,hl
    ld     b,d
    ld     c,e
    call   multiply_dehl_equals_bc_times_de                        ; DEHL = vy^2 in 16.16 velocity squared units...
    ld     l,h
    ld     h,e                                                     ; I'm going to discard 8 bits of precision here. HL = vy^2 in 8.8 vsquared units.
    pop    de
    add    hl,de                                                   ; HL = v^2 in 8.8 vsquared units.
    call   sqrt_hl_into_a                                          ; A = v in 4.4 velocity units.
    cp     10
    jp     m,ingame_box_collision_superficial                      ; If the velocity is less than a threshold, ignore it:
    ld     l,a
    ld     h,0                                                     ; Now to scale the velocity to a damage value somehow.
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl
    ex     de,hl
    ld     hl,(game.ingame_carrybox_remaining_health)
    xor    a
    sbc    hl,de                                                   ; Subtract velocity somehow; HL is now the updated carrybox health.
    jp     nc,+
    ; You've managed to get the carrybox into negative health.
    ; YOU'VE DESTROYED MARS, YOU FOOL!!
    ; Don't do anything at this point, though.
    ; When the next game frame begins, I'll check for the lose conditions,
    ; and then react to a health of zero there. (Same for timer zero.)
    ld     hl,0                                                    ; Set health to zero.
+:  ld     (game.ingame_carrybox_remaining_health),hl

ingame_box_collision_superficial:

    ; Invert and decay the box velocity so that it bounces.
    ld     de,(game.box_velocity_x)
    ld     b,d
    ld     c,e                                                     ; BC = v
    sra    b
    rr     c
    sra    b
    rr     c
    sra    b
    rr     c                                                       ; BC = v/8
    ld     hl,0
    sbc    hl,de                                                   ; HL = -v
    add    hl,bc                                                   ; HL = -((7/8)v)
    ld     (game.box_velocity_x),hl
    ld     de,(game.box_velocity_y)
    ld     b,d
    ld     c,e                                                     ; BC = v
    sra    b
    rr     c
    sra    b
    rr     c
    sra    b
    rr     c                                                       ; BC = v/8
    ld     hl,0
    sbc    hl,de                                                   ; HL = -v
    add    hl,bc                                                   ; HL = -((7/8)v)
    ld     (game.box_velocity_y),hl
ingame_box_collision_check_complete:
    ; After messing around with tricky fractional maths, update the pixel
    ; cached versions to allow the camera and sprite stuff to work
    call   ingame_update_player_and_box_position_pixels_from_fixed_point

    ; Attempt to move the camera to focus the screen on the player
    call   ingame_camera_logic_safely_track_player
    ; Update the scroll registers based on the camera's motion.
    call   ingame_camera_logic_displace_scroll_registers

.equ CARRYBOX_INITIAL_HEALTH = 35000

; These are the health thresholds for the different speeds of beeping.
; Since we're constant subtracting from the carrybox health down here,
; we subtract the difference between two successive thresholds over and over:
.equ INGAME_CARRYBOX_BEEP_THRESHOLD_1 =  24000
.equ INGAME_CARRYBOX_BEEP_THRESHOLD_2 =  19000
.equ INGAME_CARRYBOX_BEEP_THRESHOLD_3 =  14000
.equ INGAME_CARRYBOX_BEEP_THRESHOLD_4 =   9000
.equ INGAME_CARRYBOX_BEEP_THRESHOLD_5 =   4000

    ; Update carrybox flashing:
ingame_carrybox_flash_update:
    ld     a,(game.ingame_carrybox_flash_frame)
    ld     c,a                                                              ; Retrieve the current flash frame and put it in C
    ld     hl,(game.ingame_carrybox_remaining_health)
    ld     de,INGAME_CARRYBOX_BEEP_THRESHOLD_5
    xor    a
    sbc    hl,de                                                            ; Carry if the health is below the threshold.
    jp     c,ingame_carrybox_flash_update_increment_speed_5
    ld     de,INGAME_CARRYBOX_BEEP_THRESHOLD_4-INGAME_CARRYBOX_BEEP_THRESHOLD_5
    sbc    hl,de                                                            ; Carry if the health is below the threshold.
    jp     c,ingame_carrybox_flash_update_increment_speed_4
    ld     de,INGAME_CARRYBOX_BEEP_THRESHOLD_3-INGAME_CARRYBOX_BEEP_THRESHOLD_4
    sbc    hl,de                                                            ; Carry if the health is below the threshold.
    jp     c,ingame_carrybox_flash_update_increment_speed_3
    ld     de,INGAME_CARRYBOX_BEEP_THRESHOLD_2-INGAME_CARRYBOX_BEEP_THRESHOLD_3
    sbc    hl,de                                                            ; Carry if the health is below the threshold.
    jp     c,ingame_carrybox_flash_update_increment_speed_2
    ld     de,INGAME_CARRYBOX_BEEP_THRESHOLD_1-INGAME_CARRYBOX_BEEP_THRESHOLD_2
    sbc    hl,de                                                            ; Carry if the health is below the threshold.
    jp     c,ingame_carrybox_flash_update_increment_speed_1
    jp     ingame_carrybox_flash_update_complete                            ; If the health is now below any of the thresholds as we decrease, don't update the flash frame.
ingame_carrybox_flash_update_increment_speed_5:
    ld     a,c                                                              ; Different beep speeds increment the beep counter by different amounts.
    add    a,11
    jp     ingame_carrybox_flash_update_check_for_beeping
ingame_carrybox_flash_update_increment_speed_4:
    ld     a,c
    add    a,8
    jp     ingame_carrybox_flash_update_check_for_beeping
ingame_carrybox_flash_update_increment_speed_3:
    ld     a,c
    add    a,6
    jp     ingame_carrybox_flash_update_check_for_beeping
ingame_carrybox_flash_update_increment_speed_2:
    ld     a,c
    add    a,4
    jp     ingame_carrybox_flash_update_check_for_beeping
ingame_carrybox_flash_update_increment_speed_1:
    ld     a,c
    add    a,2
    jp     ingame_carrybox_flash_update_check_for_beeping
ingame_carrybox_flash_update_check_for_beeping:
    ; At this point we have the old flash frame in C and the new flash frame in A.
    ld     (game.ingame_carrybox_flash_frame),a
    ; If the bits 6 and 7 are set in A but they're not set in C, we've found a transition -into- the region 196-255
    ; and we should trigger a beep sound effect to be SCARY.
    bit    7,a
    jp     z,ingame_carrybox_flash_update_do_not_beep
    bit    6,a
    jp     z,ingame_carrybox_flash_update_do_not_beep
    bit    7,c
    jp     z,ingame_carrybox_flash_update_do_not_beep
    bit    6,c
    jp     nz,ingame_carrybox_flash_update_do_not_beep
    ld     c,1
    call   sound_force
ingame_carrybox_flash_update_do_not_beep:
ingame_carrybox_flash_update_complete:

    call   ingame_bombled_decrement_timer

ingame_paused_skip_game_simulation:


    ; This is all non-graphics stuff down here. So it's okay
    ; if we have a super long graphics-mangling frame, and then
    ; mess about with the controller and audio chip.

    call   controller_update

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick          

    ; Pause works here.
    ld     a,(var_ControllerStatus.1.StatusHit)
    bit    CONTROLLER_BIT_PAUSE,a
    jp     z,+
    ld     a,(game.game_paused)
    xor    1
    ld     (game.game_paused),a
+:

    ; Do not advance if paused.
    ld     a,(game.game_paused)
    and    a
    jp     nz,ingame_paused_skip_flow_control
    ; Check for loss, because we're going to go to a different
    ; frame if you triggered the losing animation with YOUR FOOLISHNESS.
    ld     hl,(game.ingame_carrybox_remaining_health)
    ld     a,h
    or     l
    jp     z,lose_fade_out_init
    ld     a,(game_persistent.ingame_bombled_minutes_counter)
    bit    7,a
    jp     nz,lose_fade_out_init                                     ; The minutes timer underflowed? You losed!

; Use controller 2 buttons to trigger win/loss
.endasm
    ld     a,(var_ControllerStatus.2.StatusHit)
    bit    CONTROLLER_BIT_BUTTON_1,a
    jp     z,+
    jp     lose_fade_out_init
+:
    bit    CONTROLLER_BIT_BUTTON_2,a
    jp     z,+
    jp     win_fade_out_init
+:
.asm

.equ INGAME_WINCHECK_Y = 16

    ; Check to see if we've won the universe!
    ld     a,(game.player_link_established)
    or     a
    jp     z,ingame_wincheck_player_is_not_carrying_box            ; They can't win if they're not attached to the box.
    ; Has the player won? Check to see if the player is within the destination rectangle.
    ld     hl,(game.player_position_y_pixels)                      ; Do the Y check first, because almost all the level is below the win area! (This comment made more sense when there was a 2D area of winning instead of a 1D top/bottom split.)
    ld     de,INGAME_WINCHECK_Y
    xor    a
    sbc    hl,de
    jp     p,ingame_wincheck_player_is_outside_area                ; The player wins if their Y position is less than 16 and they're holding the box.
    ; YOU'VE WON
    jp     win_fade_out_init

ingame_wincheck_player_is_not_carrying_box:
ingame_wincheck_player_is_outside_area:

ingame_paused_skip_flow_control:

    ; End of ingame frame, wait for another vblank interrupt
    jp     ingame_frame

; ========================================

; These control the size of the scrolling section (they're used in the isr)
.equ PLOT_1_ALERT_SCROLL_SECTION_Y_TOP  = 84
.equ PLOT_1_ALERT_SCROLL_SECTION_Y_SIZE = 72

plot_1_init:
    ei
    ; Set up the game state to start the plot_1 screen
    xor    a
    ld     (plot_1.anim_frame_counter),a                                          ; anim_frame_counter controls the sprite stars, the fade in and out.
    ld     (plot_1.anim_frame_counter2),a
    ld     (plot_1.anim_frame_counter2+1),a                                       ; anim_frame_counter2 controls the timing of the text paragraphs.
    ; Set up the game state to start the alert bar
    ld     (plot_1.alert_frame_counter),a                                         ; Used for the pulsing frame
    ld     (plot_1.alert_frame_counter2),a                                        ; Actually controls the logic

    ld     (plot_1.copy_nuclear_logo_flag),a                                      ; Used to control when the nuclear logo is copied.

    call   vblank_wait
    di
    call   vdp_registers_blank_screen

    call   vram_clear_all

    ; Set X scrolling to zero.
    ld     a,0
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Set Y scrolling to zero.
    ld     a,0
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollY|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Load the nuclear graphics tiles and the greenfont
    call   plot_1_vram_load_tiles
    call   plot_1_vram_construct_tiles
    ; The alert caption is constructed out of the gravity beam logo tiles.
    call   plot_1_alert_vram_copy_gravity_beam_logo_tiles
    call   plot_1_alert_vram_construct_additional_tiles

    call   plot_1_vram_populate_nametable_clear_all
    call   plot_1_alert_vram_populate_nametable_alert_text

    ld     hl,palette_data_plot_1
    ld     e,3
    call   graphics_copy_faded_palettes_to_black

;vram_greenfont_charplace_tile_cursor_x_start  db ; The tile number where the cursor should return when we hit a newline.
;vram_greenfont_charplace_tile_cursor_x        db ; The position within the nametable where the next character should be drawn
;vram_greenfont_charplace_tile_cursor_y        db
;
;vram_greenfont_charplace_string_ptr           dw ; Pointer to the next character should be printed

    ld     hl,string_plot_1_paragraph_1
    ld     (vram_greenfont_charplace_string_ptr),hl
    ld     a,2                                              ; Don't forget about the overlay column.
    ld     (vram_greenfont_charplace_tile_cursor_x_start),a
    ld     (vram_greenfont_charplace_tile_cursor_x),a
    ld     a,1
    ld     (vram_greenfont_charplace_tile_cursor_y),a
    
    ; Wait 20 frames after the first screen of text before revealing the nuke symbol.
    ld     a,20
    ld     (plot_1.anim_frame_counter2),a

    call   vdp_registers_unblank_screen                 

    ; Enable Line Interrupts (by messing around with one of the overloaded VDP registers)
    ld     a,%00110100                         ; Enable HBlank interrupts. Hide leftmost eight pixels. Enable mode 4 SMS display.
    out    (PORT_VDPControl),a
    ld     a,0|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Set up HBlank interrupts.
    ld     a,0                            ; A hblank every line, if you please.
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_HBlankCounter|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ld     hl,isr_plot_1_alert_bar_scroll
    ld     (var_isr_vector),hl                ; Switch to an ISR that scrolls the centre rows of the screen.
                        
    ; Play the plot music
    ld     hl,music_plot_1
    call   music_select_song
    call   music_resume
    
    ei

    ld     b,1
-:  call   vblank_wait
    djnz   -

plot_1_frame:
    call   vblank_wait

    di

    call   vdp_registers_blank_screen

    ; Set X scrolling to zero.
    ld     a,0
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; For frames 0 to 31, fade in the palette.
    ld     a,(plot_1.anim_frame_counter)
    cp     32
    jp     nc,+
    srl    a
    srl    a
    srl    a
    ld     b,a
    ld     a,3
    sub    b
    ld     e,a
    ld     hl,palette_data_plot_1
    call   graphics_copy_faded_palettes_to_black
+:

    ; For frames 225 to 255, fade out the palette
    ld     a,(plot_1.anim_frame_counter)
    cp     225
    jp     c,+
    sub    225
    srl    a
    srl    a
    srl    a
    ld     e,a
    ld     hl,palette_data_plot_1_nuclear_red
    call   graphics_copy_faded_palettes_to_black
+:

    ; If the alert bar is active and available to pulse:
    ld     a,(plot_1.alert_frame_counter2)
    cp     32
    jp     nz,+
    ; For frame 32, draw the dark red palette
    ld     c,13
    ld     d,3
    ld     e,0
    ld     hl,palette_data_plot_1
    call   graphics_copy_faded_palettes_to_white_limited ; We only want to mess with the last four colours.
    jp     ++
+:
    ; For frames 48 to 63, alternate between the normal and slightly faded to white frames.
    ; This makes the red bar pulsate with URGENCY.
    cp     48
    jp     c,++
    cp     63
    jp     nc,++
    sub    48
    srl    a
    srl    a
    cp     3
    jp     nz,+
    ld     a,1
+:
    ld     c,13
    ld     d,3
    ld     e,a
    ld     hl,palette_data_plot_1
    call   graphics_copy_faded_palettes_to_white_limited ; We only want to mess with the last four colours.
++:

    ; If the alert bar is active at all:
    ld     a,(plot_1.alert_frame_counter2)
    cp     64
    jp     nc,+
    ; Monkey with the scroll registers to make the alert bar move.
    ld     a,(plot_1.alert_scroll_register_x)
    dec    a
    dec    a
    ld     (plot_1.alert_scroll_register_x),a
+:

    ; Clear the logo copy flag.
    xor    a
    ld     (plot_1.copy_nuclear_logo_flag),a

    ; Only increment the text if we're between 32 and 48
    ld     a,(plot_1.anim_frame_counter)
    cp     32
    jp     m,plot_1_frame_dont_increment_text
    cp     48
    jp     nc,plot_1_frame_dont_increment_text
    ; Add a letter every Nth frame.
    and    1
    jp     nz,plot_1_frame_dont_increment_text
    call   vram_place_greenfont_charplace_place_next
    ; If the text has finished,
    ld     hl,(vram_greenfont_charplace_string_ptr)
    ld     a,h
    or     l
    jp     nz,plot_1_frame_dont_change_page
    ; Have we seen the full page for long enough?
    ld     a,(plot_1.anim_frame_counter2)
    cp     0
    jp     z,+
    ; Decrement counter2 to tally up the number of frames we've seen the full page.
    dec    a
    ld     (plot_1.anim_frame_counter2),a
    jp     plot_1_frame_page_change_complete
+:  ; Change the page. Check what page we're on:
    ld     a,(plot_1.anim_frame_counter2+1)
    cp     0
    jp     nz,+
    ; We've finished displaying the first paragraph. Fade in the nuclear symbol by changing
    ; the anim_frame_counter to 49 and the paragraph to 1.
    ; Disable Line Interrupts (by messing around with one of the overloaded VDP registers)
    ld     a,%00100100                         ; Hide leftmost eight pixels. Enable mode 4 SMS display.
    out    (PORT_VDPControl),a
    ld     a,0|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
    ; Set the HBlank counter to something big.
    ld     a,200
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_HBlankCounter|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
    ld     hl,isr_vblank_only
    ld     (var_isr_vector),hl                ; Back to the normal ISR please.
    ld     a,64                               ; 64 jams the counter, do nothing with the alert palette from now.
    ld     (plot_1.alert_frame_counter2),a
    ld     a,49
    ld     (plot_1.anim_frame_counter),a
    ld     a,1
    ld     (plot_1.anim_frame_counter2+1),a
    ld     (plot_1.copy_nuclear_logo_flag),a  ; Copy the logo ASAP.
    ld     a,20                               ; Show the logo for this many frames.
    ld     (plot_1.anim_frame_counter2),a
    jp     plot_1_frame_page_change_complete
+:  cp     2
    jp     nz,+
    ; SCARY
    ld     e,0
    ld     hl,palette_data_plot_1_nuclear_red
    call   graphics_copy_faded_palettes_to_black
    ld     a,32
    ld     (plot_1.anim_frame_counter),a
    ld     a,3
    ld     (plot_1.anim_frame_counter2+1),a
    ld     a,50                               ; Show red for this many frames.
    ld     (plot_1.anim_frame_counter2),a
    jp     plot_1_frame_page_change_complete
+:  cp     3
    jp     nz,+
    ; Fade out.
    ld     a,225
    ld     (plot_1.anim_frame_counter),a
    ;jp     plot_1_frame_page_change_complete

plot_1_frame_page_change_complete:
plot_1_frame_dont_change_page:
plot_1_frame_dont_increment_text:

    ; Only fade in the nuke symbol if we're between 49 and 49+30
    ld     a,(plot_1.anim_frame_counter)
    cp     224
    jp     z,plot_1_frame_to_final_paragraph
    cp     49
    jp     m,plot_1_frame_dont_nuke_symbol_palette
    cp     49+30
    jp     nc,plot_1_frame_dont_nuke_symbol_palette
    sub    49
    srl    a
    srl    a
    srl    a
    ld     b,a
    ld     a,3
    sub    b
    ld     e,a
    ld     hl,palette_data_plot_1_nuclear
    call   graphics_copy_faded_palettes_to_black
    ld     bc,VDPCommand_CRAMWrite|$0008   ; Maintain the last eight colours.
    SetVDPAddress_bc_UNSAFE
    ld     hl,palette_data_plot_1+8
    ld     b,8
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    djnz   -
    jp     plot_1_frame_nuke_symbol_palette_complete
plot_1_frame_to_final_paragraph:
    ld     a,32                                ; Set up the printing of the text below the nuclear.
    ld     (plot_1.anim_frame_counter),a
    ld     a,2
    ld     (plot_1.anim_frame_counter2+1),a

    ld     hl,string_plot_1_paragraph_2
    ld     (vram_greenfont_charplace_string_ptr),hl
    ld     a,2                                              ; Don't forget about the overlay column.
    ld     (vram_greenfont_charplace_tile_cursor_x_start),a
    ld     (vram_greenfont_charplace_tile_cursor_x),a
    ld     a,21
    ld     (vram_greenfont_charplace_tile_cursor_y),a

plot_1_frame_dont_nuke_symbol_palette:
plot_1_frame_nuke_symbol_palette_complete:

    call   vdp_registers_unblank_screen

; Draw the nuclear symbol outside of blank/unblank time to prevent flickering.
    ld     a,(plot_1.copy_nuclear_logo_flag)
    and    a
    jp     z,+
    xor    a
    ld     (plot_1.copy_nuclear_logo_flag),a
    call   plot_1_vram_populate_nametable_draw_nuke_symbol
+:

    ei

    call   controller_update

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    ; Increment the animation counter.
    ld     a,(plot_1.anim_frame_counter)
    cp     48                             ; Loop 48 back to 32.
    jp     z,+
    inc    a
    ld     (plot_1.anim_frame_counter),a
    jp     ++
+:  ld     a,32
    ld     (plot_1.anim_frame_counter),a
++: cp     255
    jp     z,plot_2_init   ; The second page has been displayed for long enough. Move to fade out.

    ; Increment the pulse counter.
    ld     a,(plot_1.alert_frame_counter2)
    cp     64                             ; 64 jams the counter, do nothing.
    jp     z,++
    cp     63                             ; Loop 63 back to 32.
    jp     z,+
    inc    a
    ld     (plot_1.alert_frame_counter2),a
    jp     ++
+:  ld     a,32
    ld     (plot_1.alert_frame_counter2),a
++:

    ; Allow the player to press BUTTON 1 or 2 to skip to title.
    ld     a,(plot_1.anim_frame_counter)
    ld     a,(var_ControllerStatus.1.StatusCurrent)
    bit    CONTROLLER_BIT_BUTTON_1,a
    jp     z,+
    jp     title_init_jump_from_plot_1
+:
    bit    CONTROLLER_BIT_BUTTON_2,a
    jp     z,+
    jp     title_init_jump_from_plot_1
+:

    jp     plot_1_frame
    
plot_1_vram_load_tiles:
    ; Decompress the radioactive 2bpp logo into RAM temporarily. (It's huffman encoded, and then crushed to 2bpp, so it needs to be expanded from RAM to VRAM!)
    ld     bc,ha1_graphics_plot_1_radioactive_2bpp_bin_fullsize
    ld     de,plot_1.graphics_radioactive_2bpp_decompressed
    ld     hl,ha1_graphics_plot_1_radioactive_2bpp_bin_data
    call   ha1_decompress

    ; Load the radioactive logo into the low tiles.
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|0
    SetVDPAddress_de_UNSAFE
    ld     hl,plot_1.graphics_radioactive_2bpp_decompressed
    ld     b,304/2
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a                             ; Load first two bitplanes.
    ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    ld     a,%11111111                                  ; Bitplane 3 is all ones.
    out    (PORT_VDPData),a
    xor    a                                            ; Bitplane 4 is all zeroes.
    out    (PORT_VDPData),a
    djnz   -

    ld     hl,19
    call   vram_load_greenfont_tiles

    ret

plot_1_vram_construct_tiles
    ; Construct a completely black (colour 0) tile in tile X.
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|(32*99)
    SetVDPAddress_de_UNSAFE
    ld     b,8                       ; 8 rows down a tile.
-:
    xor    a
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    djnz   -
    ret

plot_1_vram_populate_nametable_clear_all:
    ; Fill the screen with tile A.
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|((0)*2)
    SetVDPAddress_UNSAFE
    ld     bc,32*32                           ; Tiles counter
-:  ld     a,99
    out    (PORT_VDPData),a
    xor    a                                  ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    dec    bc
    ld     a,b
    or     c
    jp     nz,-
    ret

plot_1_vram_populate_nametable_draw_nuke_symbol:
    ; Draw eight rows of the yellow tile from the radioactive symbol.
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*11)+0)*2)
    SetVDPAddress_UNSAFE
    ld     bc,32*8                            ; Tiles counter
-:  ld     a,3
    out    (PORT_VDPData),a
    call   waste_27_t_states
    xor    a                                  ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    dec    bc
    ld     a,b
    or     c
    jp     nz,-

    ; Draw the radioactive symbol.
    ; Draw 8 tiles reading the map backwards, then 8 reading it forwards.
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*11)+4)*2)
    ld     de,graphics_plot_1_radioactive_2bpp_map+7
    ld     c,8                                ; C is counter of number of rows to place.
--: SetVDPAddress_UNSAFE
    ld     b,8
-:  ld     a,(de)                             ; Read data from the map, backwards.
    out    (PORT_VDPData),a
    call   waste_27_t_states
    ld     a,2                                ; Horizontal flip for the first eight.
    out    (PORT_VDPData),a
    dec    de
    djnz   -
    ld     b,8
-:  inc    de
    ld     a,(de)
    out    (PORT_VDPData),a
    call   waste_27_t_states
    ld     a,0                                ; Second eight are not flipped
    out    (PORT_VDPData),a
    djnz   -
    dec    c
    jp     z,+
    push   bc
    ld     bc,32*2
    add    hl,bc                              ; Advance to the next row of the nametable.
    ex     de,hl
    ld     bc,8
    add    hl,bc                              ; Advance to the next row of the map
    ex     de,hl
    pop    bc
    jp     --
+:
    ret
    
plot_1_alert_vram_construct_additional_tiles:
    ; Construct a tile that looks like an equals sign in tile 100
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|(32*100)
    SetVDPAddress_de_UNSAFE

    ld     c,%11111111 ; All active bits
    ld     d,%00000000 ; All inactive bits

    ld     b,3                       ; B is used to count number of pixel rows.
    ; Colour 13 (%1101) please. (dark red)
-:  ld     a,c
    out    (PORT_VDPData),a
    ld     a,d
    out    (PORT_VDPData),a
    ld     a,c
    out    (PORT_VDPData),a
    ld     a,c
    out    (PORT_VDPData),a
    djnz   -

    ; Colour 14 (%1110) please. (light red)
    ld     a,d
    out    (PORT_VDPData),a
    ld     a,c
    out    (PORT_VDPData),a
    ld     a,c
    out    (PORT_VDPData),a
    ld     a,c
    out    (PORT_VDPData),a

    ; Colour 15 (%1111) please. (mid red)
    nop
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a

    ; Colour 14 (%1110) please. (light red)
    ld     a,d
    out    (PORT_VDPData),a
    ld     a,c
    out    (PORT_VDPData),a
    ld     a,c
    out    (PORT_VDPData),a
    ld     a,c
    out    (PORT_VDPData),a

    ld     b,2                       ; B is used to count number of pixel rows.
    ; Colour 13 (%1101) please. (dark red)
-:  ld     a,c
    out    (PORT_VDPData),a
    ld     a,d
    out    (PORT_VDPData),a
    ld     a,c
    out    (PORT_VDPData),a
    ld     a,c
    out    (PORT_VDPData),a
    djnz   -

    ret

plot_1_alert_vram_copy_gravity_beam_logo_tiles:
    ; Copy the gravity beam logo tile fragments into tiles 101-127 (used to construct the alert bar)
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|(32*101)
    SetVDPAddress_de_UNSAFE
    ld     bc,graphics_title_gravitybeamlogo_end-graphics_title_gravitybeamlogo
    ld     hl,graphics_title_gravitybeamlogo
    ; I've encoded it as a 2bpp planar tile thing. I'm going to expand that into a 4bpp palette using bitwise operations
    ; Source             Destination
    ; 0       00          D 1101
    ; 1       01   --->   E 1110
    ; 2       10   --->   E 1110
    ; 3       11          F 1111
-:  ld     d,(hl)
    inc    hl
    ld     e,(hl)
    inc    hl

    ; Bit 1 = not (LSB xor MSB)
    ld     a,d
    xor    e
    cpl
    out    (PORT_VDPData),a
    ; Bit 1 = (LSB or MSB)
    ld     a,d
    or     e
    out    (PORT_VDPData),a
    ld     a,%11111111                                  ; Bitplane 3 is all ones.
    out    (PORT_VDPData),a
    nop                                                 ; Bitplane 4 is all ones.
    out    (PORT_VDPData),a
    dec    bc
    dec    bc
    ld     a,b
    or     c
    jp     nz,-
    ret
    
plot_1_alert_vram_populate_nametable_alert_text:
    ; Draw the two stripes.
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|((32*11)*2)
    SetVDPAddress_UNSAFE
    ld     b,32                                         ; B is horizontal counter.
-:  ld     a,100                                        ; Stripe tile
    out    (PORT_VDPData),a
    xor    a                                            ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -

    ; Fill in the middle area with the dark red tiles to make a solid bar.

    ld     c,6                                          ; C is vertical counter.
--: ld     b,32                                         ; B is horizontal counter.
-:  ld     a,101                                        ; Solid dark red fill tile from the GB logo loading
    out    (PORT_VDPData),a
    xor    a                                            ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -
    dec    c
    jp     nz,--

    ld     b,32                                         ; B is horizontal counter.
-:  ld     a,100                                        ; Stripe tile
    out    (PORT_VDPData),a
    xor    a                                            ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -

    ; Populate the nametable with the ALERT scrolling text constructed from the
    ; tiles from the Gravity Beam logo.

    ; Draw it twice, two locations, side by side.
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*13)+1)*2)
    ld     de,graphics_alert_alerttext_map
    ld     c,4                                          ; C is vertical counter.
--: ld     b,10                                         ; B is horizontal counter.
    SetVDPAddress_UNSAFE
-:  ld     a,(de)                                       ; Load tile number from map.
    inc    de
    out    (PORT_VDPData),a
    xor    a                                            ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -
    push   de
    ld     de,32*2
    add    hl,de                                        ; Advance to next line of nametable.
    pop    de
    dec    c
    jp     nz,--

    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*13)+17)*2)
    ld     de,graphics_alert_alerttext_map
    ld     c,4                                          ; C is vertical counter.
--: ld     b,10                                         ; B is horizontal counter.
    SetVDPAddress_UNSAFE
-:  ld     a,(de)                                       ; Load tile number from map.
    inc    de
    out    (PORT_VDPData),a
    xor    a                                            ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -
    push   de
    ld     de,32*2
    add    hl,de                                        ; Advance to next line of nametable.
    pop    de
    dec    c
    jp     nz,--
    ret



.endasm
Real characters
0123456789:;<=>?
@ABCDEFGHJIKLMNO
PQRSTUVWXYZ[\]^_
`abcdefghijklmno
pqrstuvwxyz{|}~nbsp (char $7F CHAR_FULLSTOP)

Greenfont output

0123456789:;'!"?
ABCDEFGHIJKLMNO
PQRSTUVWXYZ[]+-
_abcdefghijklmno
pqrstuvwxyz[\/,.

$80 is the character after the full stop.

For the plot screens, I'm setting that to an all black tile (different to the transparent
tile zero as it's not transparent, it's 'BLACK')

.asm

.asciitable
MAP " " = $80   ; The plot screens use a different tile for their space character.
MAP ":" = ':'
MAP ";" = ';'
MAP "'" = '<'
MAP "!" = '='
MAP "\"" = '>'
MAP "?" = '?'
MAP "@" = '@'
MAP "[" = '['
MAP "" = '\'
MAP "]" = ']'
MAP "+" = '^'
MAP "-" = '_'
MAP "_" = '`'
MAP "5" = '|'
MAP "/" = '}'
MAP "," = $7E
MAP "." = $7F
MAP "`" = $80
MAP "$" = 1
.enda

string_plot_1_paragraph_1:
;    [-----------------------------]   ; For plot 1, there are 9 lines total available..
.asc "                   $"
.asc "Eco-terrorists have attacked$" ; Frankly, everybody gets called a terrorist these days. What happened to good old fashioned 'crazy guy' or 'bad guy'?
.asc "   the colonists of Mars,   $"
.asc "  demanding they cease all  $"
.asc "mining activity immediately.$"
.asc "        $" ; This line dramatically left blank.
.asc " They have a nuclear weapon $"
.asc "that can destroy the planet.$"
.db 0
string_plot_1_paragraph_2:
.asc "  NEGOTIATIONS HAVE FAILED$"
.db 0

; This is an array of tiles constructing a single ALERT caption from
; the tiles of the Gravity Beam logo.
; Add on a constant representing the offset into the pattern RAM
; as we're not loading the GB logo pattern data into tile zero.
.equ AO = 101

graphics_alert_alerttext_map:
.db $01+AO,$02+AO, $04+AO,$00+AO, $03+AO,$07+AO, $03+AO,$02+AO, $05+AO,$06+AO
.db $09+AO,$09+AO, $09+AO,$00+AO, $09+AO,$00+AO, $09+AO,$09+AO, $0A+AO,$0B+AO
.db $10+AO,$12+AO, $09+AO,$00+AO, $10+AO,$13+AO, $10+AO,$11+AO, $0A+AO,$0B+AO
.db $0C+AO,$0C+AO, $16+AO,$1A+AO, $16+AO,$1A+AO, $0C+AO,$0C+AO, $18+AO,$19+AO

; ========================================


plot_2_init:

    ld     b,10

-:  call   vblank_wait

    push   bc

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    pop    bc
    djnz   -

    ; Play the plot music
    ld     hl,music_plot_2
    call   music_select_song
    call   music_resume


    ei
    ; Set up the game state to start the plot_2 screen
    xor    a
    ld     (plot_2.anim_frame_counter),a                                          ; anim_frame_counter controls the sprite stars, the fade in and out.
    ld     (plot_2.anim_frame_counter2),a
    ld     (plot_2.anim_frame_counter2+1),a                                       ; anim_frame_counter2 controls the timing of the text paragraphs.
    ld     (plot_2.stars_anim_frame_counter),a

    call   vblank_wait
    di
    call   vdp_registers_blank_screen

    call   vram_clear_all

    ; Set X scrolling to zero.
    ld     a,0
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Set Y scrolling to zero.
    ld     a,0
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollY|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Decompress the greenwing large sprites into the background tiles.
    ; We only want so many of them (not using the small tiles.)
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM
    SetVDPAddress_de_UNSAFE
    ld     bc,32*85
    ld     de,0
    ld     hl,ha1_graphics_ending_greenwingsprites_4bpp_bin_data
    call   ha1_decompress

    call   plot_2_vram_construct_additional_tiles
    ; Nab a couple of the space tiles from the ending screen to show stars behind the greenwing.
    call   plot_2_vram_copy_space_tiles
    ; Nab a couple of the space tiles again from the ending screen to show stars as sprites.
    call   plot_2_vram_copy_space_tiles_as_sprites

    ld     hl,85
    call   vram_load_greenfont_tiles_alternate_plot_2

    call   plot_2_vram_populate_nametable

    ld     hl,palette_data_plot_2
    ld     e,3
    call   graphics_copy_faded_palettes_to_black

;vram_greenfont_charplace_tile_cursor_x_start  db ; The tile number where the cursor should return when we hit a newline.
;vram_greenfont_charplace_tile_cursor_x        db ; The position within the nametable where the next character should be drawn
;vram_greenfont_charplace_tile_cursor_y        db
;
;vram_greenfont_charplace_string_ptr           dw ; Pointer to the next character should be printed

    ld     hl,string_plot_2_paragraph_1
    ld     (vram_greenfont_charplace_string_ptr),hl
    ld     a,1                                                ; Don't forget about the overlay column.
    ld     (vram_greenfont_charplace_tile_cursor_x_start),a
    ld     (vram_greenfont_charplace_tile_cursor_x),a
    ld     (vram_greenfont_charplace_tile_cursor_y),a

    call   vdp_registers_unblank_screen

    ei


plot_2_frame:
    call   vblank_wait

    di

    call   vdp_registers_blank_screen

    ; For frames 0 to 31, fade in the palette
    ld     a,(plot_2.anim_frame_counter)
    cp     32
    jp     nc,+
    srl    a
    srl    a
    srl    a
    ld     b,a
    ld     a,3
    sub    b
    ld     e,a
    ld     hl,palette_data_plot_2
    call   graphics_copy_faded_palettes_to_black
+:
    ; For frames 49 to 79, fade out the palette
    ld     a,(plot_2.anim_frame_counter)
    cp     49
    jp     c,+
    sub    49
    srl    a
    srl    a
    srl    a
    ld     e,a
    ld     hl,palette_data_plot_2
    call   graphics_copy_faded_palettes_to_black
+:

    ; Only flash the engines if we're between 32 and 48
    ld     a,(plot_2.anim_frame_counter)
    cp     32
    jp     m,plot_2_frame_dont_flash_engines
    cp     48
    jp     nc,plot_2_frame_dont_flash_engines
    and    4
    ld     e,0
    ld     hl,palette_data_plot_2
    jp     z,+
    ld     hl,palette_data_plot_2_alternate
+:  call   graphics_copy_faded_palettes_to_black
plot_2_frame_dont_flash_engines:

    xor    a
    ld     a,(plot_2.clear_text_on_page_switch_flag)        ; Flag for clearing the text half of the screen.
    ; Only increment the text if we're between 32 and 48
    ld     a,(plot_2.anim_frame_counter)
    cp     32
    jp     m,plot_2_frame_dont_increment_text
    cp     48
    jp     nc,plot_2_frame_dont_increment_text
    ; Add a letter every Nth frame.
    and    1
    jp     nz,plot_2_frame_dont_increment_text
    call   vram_place_greenfont_charplace_place_next
    ; If the text has finished,
    ld     hl,(vram_greenfont_charplace_string_ptr)
    ld     a,h
    or     l
    jp     nz,plot_2_frame_dont_change_page
    ; Have we seen the full page for long enough?
    ld     a,(plot_2.anim_frame_counter2)
    cp     140
    jp     z,+
    ; Increment counter2 to tally up the number of frames we've seen the full page.
    inc    a
    ld     (plot_2.anim_frame_counter2),a
    jp     plot_2_frame_page_change_complete
+:  ; Change the page. Check what page we're on:
    ld     a,(plot_2.anim_frame_counter2+1)
    cp     1                              ; If this is 1, we've seen the second page for long.
    jp     z,+                            ; Otherwise, we've seen the first page for long and should change to the second.
    ; Set the page to the second page and clear the screen, set the pointers etc.
    ld     hl,string_plot_2_paragraph_2
    ld     (vram_greenfont_charplace_string_ptr),hl
    ld     a,1
    ld     (vram_greenfont_charplace_tile_cursor_x_start),a
    ld     (vram_greenfont_charplace_tile_cursor_x),a
    ld     (vram_greenfont_charplace_tile_cursor_y),a
    ld     (plot_2.anim_frame_counter2+1),a
    ld     (plot_2.clear_text_on_page_switch_flag),a      ; Set the flag for clearing the text half of the screen when we have enough time.
    xor    a
    ld     (plot_2.anim_frame_counter2),a
    jp     plot_2_frame_page_change_complete
+:  ld     a,49                                  ; Go to the fade out frame number
    ld     (plot_2.anim_frame_counter),a

plot_2_frame_page_change_complete:
plot_2_frame_dont_change_page:
plot_2_frame_dont_increment_text:

    push   bc                                    ; Preserve the B flag.
    call   vdp_registers_unblank_screen
    call   plot_2_place_star_sprites
    pop    bc

    ; Clearing the text half of the screen during the page transition OUTSIDE of the blank/unblank
    ; means that the screen doesn't flicker black during it.
    ld     a,(plot_2.clear_text_on_page_switch_flag)
    and    a
    jp     z,+
    ; Clear the bottom half of the text if we need to (can't do it during the blank/unblank because it's too long.)
    xor    a
    ld     (plot_2.clear_text_on_page_switch_flag),a
    call   plot_2_vram_populate_nametable_clear_text
+:

    ei

    call   controller_update

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    ; Increment the animation counter.
    ld     a,(plot_2.anim_frame_counter)
    cp     48
    jp     z,+
    inc    a
    ld     (plot_2.anim_frame_counter),a
    jp     ++
+:  ld     a,32
    ld     (plot_2.anim_frame_counter),a
++: cp     80
    jp     z,title_init   ; The second page has been displayed for long enough. Move to fade out.
    
    ; Advance start
    ld     a,(plot_2.stars_anim_frame_counter)
    inc    a
    ld     (plot_2.stars_anim_frame_counter),a

    ; Allow the player to press BUTTON 1 or 2 to skip to title.
    ld     a,(plot_2.anim_frame_counter)
    ld     a,(var_ControllerStatus.1.StatusCurrent)
    bit    CONTROLLER_BIT_BUTTON_1,a
    jp     z,+
    jp     title_init
+:
    bit    CONTROLLER_BIT_BUTTON_2,a
    jp     z,+
    jp     title_init
+:

    jp     plot_2_frame

.endasm
Real characters
0123456789:;<=>?
@ABCDEFGHJIKLMNO
PQRSTUVWXYZ[\]^_
`abcdefghijklmno
pqrstuvwxyz{|}~nbsp (char $7F CHAR_FULLSTOP)

Greenfont output

0123456789:;'!"?
ABCDEFGHIJKLMNO
PQRSTUVWXYZ[]+-
_abcdefghijklmno
pqrstuvwxyz[\/,.

$80 is the character after the full stop.

For the plot screens, I'm setting that to an all black tile (different to the transparent
tile zero as it's not transparent, it's 'BLACK')

.asm

.asciitable
MAP " " = $80   ; The plot screens use a different tile for their space character.
MAP ":" = ':'
MAP ";" = ';'
MAP "'" = '<'
MAP "!" = '='
MAP "\"" = '>'
MAP "?" = '?'
MAP "@" = '@'
MAP "[" = '['
MAP "" = '\'
MAP "]" = ']'
MAP "+" = '^'
MAP "-" = '_'
MAP "_" = '`'
MAP "5" = '|'
MAP "/" = '}'
MAP "," = $7E
MAP "." = $7F
MAP "`" = $80
MAP "$" = 1
.enda

string_plot_2_paragraph_1:
; byte 1 indicates a special newline character for the 'greenfont_charplace' routine.
;    [-----------------]   22 lines of text. (if you're slow, that means that .db 0 should be 22 lines after the first .asc line)
.asc "A desperate call$"
.asc "for help is sent.$"
.asc "                 $"
.asc "A lone ship hears$"
.asc "the distress call.$"
.asc "                 $"
.asc "With only minutes$"
.asc "before the bomb$"
.asc "detonates, you$"
.asc "fly directly into$"
.asc "the caverns of$"
.asc "Mars...$"
.asc "                 $"
.asc "You and your ship$"
.asc "the GREENWING are$"
.asc "Mars' last hope.$"
.asc "                 $"
.asc "You've never had$"
.asc "to carry a nuke$"
.asc "before, but how$"
.asc "dangerous could$"
.asc "it possibly be?$"
.db 0

string_plot_2_paragraph_2:
; byte 1 indicates a special newline character for the 'greenfont_charplace' routine.
;    [-----------------]   22 lines of text. (if you're slow, that means that .db 0 should be 22 lines after the first .asc line)
.asc "Your mission:$"
.asc "                 $"
.asc "Enter the caverns$"
.asc "of Mars, and$"
.asc "locate the$"
.asc "nuclear device.$"
.asc "                 $"
.asc "Engage your ships$"
.asc "GRAVITY BEAM to$"
.asc "attach the device$"
.asc "to your ship.$"
.asc "                 $"
.asc "Next, carefully$"
.asc "carry it back$"
.asc "through the caves$"
.asc "and into space,$"
.asc "where it can then$"
.asc "be detonated$"
.asc "safely.$"
.asc "                 $"
.asc "GOOD LUCK, pilot,$"
.asc "and GODSPEED.$"
.db 0

plot_2_vram_construct_additional_tiles:
    ; Construct a completely black (colour 1) tile in tile 165
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|(32*165)
    SetVDPAddress_de_UNSAFE
    ld     b,8                       ; 8 rows down a tile.
-:  ld     a,%11111111
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    djnz   -
    ret

plot_2_vram_populate_nametable:
    ; Fill the screen with X columns of black (tile 165) and Y columns of blue (tile 0)
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|((0)*2)
    SetVDPAddress_UNSAFE
    ld     c,24                                          ; C is vertical counter.
--: ld     b,32                                          ; B is horizontal counter.
-:  ld     a,b
    cp     14                                            ; we're comparing on B, which decrements, so this is the size of the BLACK area.
    ld     a,0
    jp     m,+
    ld     a,165
+:  out    (PORT_VDPData),a
    xor    a                                             ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -
    dec    c
    jp     nz,--

    ; Draw the greenwing on the right!
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|((32*7+22)*2)
    ld     de,graphics_ending_greenwingsprites_map
    ld     c,16                                          ; C is vertical counter.
--: SetVDPAddress_UNSAFE
    ld     b,8                                           ; B is horizontal counter.
-:  ld     a,(de)
    inc    de
    out    (PORT_VDPData),a
    xor    a                                             ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -
    push   de
    ld     de,32*2
    add    hl,de
    pop    de
    dec    c
    jp     nz,--

    ; Draw some space tiles around the greenwing.
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|((32*1+21)*2)
    SetVDPAddress_UNSAFE
    ld     a,166
    out    (PORT_VDPData),a
    xor    a                                             ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|((32*2+29)*2)
    SetVDPAddress_UNSAFE
    ld     a,167
    out    (PORT_VDPData),a
    xor    a                                             ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|((32*8+20)*2)
    SetVDPAddress_UNSAFE
    ld     a,167
    out    (PORT_VDPData),a
    xor    a                                             ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|((32*12+30)*2)
    SetVDPAddress_UNSAFE
    ld     a,166
    out    (PORT_VDPData),a
    xor    a                                             ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|((32*22+25)*2)
    SetVDPAddress_UNSAFE
    ld     a,166
    out    (PORT_VDPData),a
    xor    a                                             ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a

    ret

plot_2_vram_populate_nametable_clear_text:
    ; Fill the screen with B columns of black (tile 165)
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|((1+32)*2)
    ld     c,22                                          ; C is vertical counter.
--: SetVDPAddress_UNSAFE
    ld     b,18                                          ; B is horizontal counter.
-:  ld     a,165
    out    (PORT_VDPData),a
    ; We're doing this outside the screen blank/unblank, so let's get it right.
    call   waste_27_t_states
    xor    a                                             ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -
    ld     de,32*2
    add    hl,de
    dec    c
    jp     nz,--
    ret

plot_2_vram_copy_space_tiles:
    ; Copy a couple of the ending space tiles to VRAM tiles 166-167
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|$0000+32*166
    SetVDPAddress_de_UNSAFE
    ld     hl,graphics_ending_space_tiles
    ld     b,16
    ; Map colours 8 and 9 to colours
-:  ld     d,(hl)
    inc    hl
    ld     e,(hl)
    inc    hl
    ; I've encoded it as a 2bpp planar tile thing. I'm going to expand that into a 4bpp palette using bitwise operations
    ; Source             Destination
    ; 0       00          0 0000
    ; 1       01   --->   0 0000
    ; 2       10   --->   C 1100
    ; 3       11          5 0101
    ld     a,e
    and    d
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    ld     a,e
    out    (PORT_VDPData),a
    ld     a,d
    cpl
    and    e
    out    (PORT_VDPData),a
    djnz   -

    ret

plot_2_vram_copy_space_tiles_as_sprites:
    ; Copy a couple of the ending space tiles to VRAM tiles 256,257
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|$0000+32*256
    SetVDPAddress_de_UNSAFE
    ld     hl,graphics_ending_space_tiles
    ld     b,16
    ; Map colours 8 and 9 to colours
-:  ld     d,(hl)
    inc    hl
    ld     e,(hl)
    inc    hl
    ; Source             Destination
    ; 0       00          0 0000
    ; 1       01   --->   0 0000
    ; 2       10   --->   C 1100
    ; 3       11          5 0101
    ld     a,e
    and    d
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    ld     a,e
    out    (PORT_VDPData),a
    ld     a,d
    cpl
    and    e
    out    (PORT_VDPData),a
    djnz   -

    ret
    
plot_2_place_star_sprites:
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+0       ; Place this into the appropriate memory location for Sprite 0 in $3F00-based table.
    SetVDPAddress_de_UNSAFE
    
    ; C is persistent X counter that wraps all over the place.
    ld     a,(plot_2.stars_anim_frame_counter)
    ld     c,a
    add    a,c
    add    a,c
    ld     c,a

.equ PLOT_2_NO_STARS = 16

    ; Go through and place 32 star sprites at positions based on the plot_2.stars_anim_frame_counter variable.
    ld     b,PLOT_2_NO_STARS
-:  ld     a,c
    add    a,45                               ; Advance and store X counter.
    ld     c,a
    cp     151                                ; Hide sprites that are to the left of the blue cinematic area.
    jp     nc,+
    xor    a
+:  out    (PORT_VDPData),a                   ; Output X coordinate.
    ld     a,b
    and    1
    out    (PORT_VDPData),a                   ; Output tile number.
    djnz   -

    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+0        ; Place this into the appropriate memory location for Sprite 0 in $3F00-based table.
    SetVDPAddress_de_UNSAFE

    ; C is persistent Y counter that wraps all over the place.
    ld     a,(plot_2.stars_anim_frame_counter)
    ld     c,a
    add    a,c
    add    a,c
    add    a,c
    add    a,c
    add    a,c
    ld     c,a

    ld     b,PLOT_2_NO_STARS
-:  ld     a,c
    add    a,26                                ; Advance and store Y counter.
    add    a,b
    ld     c,a
    out    (PORT_VDPData),a                   ; Output Y coordinate.
    djnz   -

    ret

; Redefine the space character back into the space character.
; This is so that we get tile 0 when we do the text for the 
; CONTACT LOST and win cinematic scenes.
.asciitable
MAP " " = ' '
MAP ":" = ':'
MAP ";" = ';'
MAP "'" = '<'
MAP "!" = '='
MAP "\"" = '>'
MAP "?" = '?'
MAP "@" = '@'
MAP "[" = '['
MAP "" = '\'
MAP "]" = ']'
MAP "+" = '^'
MAP "-" = '_'
MAP "_" = '`'
MAP "5" = '|'
MAP "/" = '}'
MAP "," = $7E
MAP "." = $7F
MAP "`" = $80
; ` is the black space.
.enda

; ========================================

title_init_jump_from_plot_1:

    ; Play the plot 2 music if we jumped from plot 1 without ending.
    ld     hl,music_plot_2
    call   music_select_song
    call   music_resume

    ld     b,2

-:  call   vblank_wait

    push   bc

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    pop    bc
    djnz   -

title_init:
    ; Set up the game state to start the title screen
    xor    a
    ld     (title.anim_frame_counter),a
    ld     (title.pressed_start),a
    ld     (title.menu_cursor_position),a
    ld     (game_persistent.controls_inverted),a

    di
    call   vdp_registers_blank_screen

    ; Disable Line Interrupts (by messing around with one of the overloaded VDP registers)
    ld     a,%00100100                         ; Hide leftmost eight pixels. Enable mode 4 SMS display.
    out    (PORT_VDPControl),a
    ld     a,0|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
    ; Set the HBlank counter to something big.
    ld     a,200
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_HBlankCounter|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
    ld     hl,isr_vblank_only
    ld     (var_isr_vector),hl                ; Back to the normal ISR please.

    ld     hl,palette_data_title
    ld     e,3
    call   graphics_copy_faded_palettes_to_black

    call   vram_clear_all

    ; Set X scrolling to zero.
    ld     a,0
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Set Y scrolling to zero.
    ld     a,0
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollY|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    call   title_vram_copy_tiles
    call   title_vram_populate_nametable_gravity_beam_logo     
    call   title_vram_populate_nametable_master_gaiden_string

    ; Put the greenwing in the right place.

    ld     a,100
    ld     (title.greenwing_x),a
    ld     a,88
    ld     (title.greenwing_y),a
    call   title_frame_place_greenwing_sprite

    call   vdp_registers_unblank_screen

    ei

title_frame:
    call   vblank_wait

    di

    call   vdp_registers_blank_screen

    ; For frames 0 to 15, fade in the title palette, with the text colours jammed to zero.
    ld     a,(title.anim_frame_counter)
    cp     15
    jp     nc,+
    srl    a
    srl    a
    ld     b,a
    ld     a,3
    sub    b
    ; Copy D colours, starting from the Cth.
    ld     d,3
    ld     c,1
    ld     e,a
    ld     hl,palette_data_title
    call   graphics_copy_faded_palettes_to_black_limited
    jp     title_frame_palette_alteration_complete
.equ TITLE_MASTER_GAIDEN_FADE_IN_FRAME = 109
.equ TITLE_MASTER_GAIDEN_FADE_OUT_FRAME = 255-15
+:  ; For frames TITLE_MASTER_GAIDEN_FADE_IN_FRAME to TITLE_MASTER_GAIDEN_FADE_IN_FRAME+15, fade in the title palette, with the gravity beam logo colours jammed to 'on'.
    ld     a,(title.anim_frame_counter)
    cp     TITLE_MASTER_GAIDEN_FADE_IN_FRAME
    jp     c,+
    cp     TITLE_MASTER_GAIDEN_FADE_IN_FRAME+16
    jp     nc,+
    sub    TITLE_MASTER_GAIDEN_FADE_IN_FRAME
    srl    a
    srl    a
    ld     b,a
    ld     a,3
    sub    b
    ld     e,a
    ld     hl,palette_data_title
    call   graphics_copy_faded_palettes_to_black
    ld     bc,VDPCommand_CRAMWrite|$0000
    SetVDPAddress_bc_UNSAFE
    ld     hl,palette_data_title
    ld     a,(hl)
    out    (PORT_VDPData),a
    inc    hl
    ld     a,(hl)
    out    (PORT_VDPData),a
    inc    hl
    ld     a,(hl)
    out    (PORT_VDPData),a
    inc    hl
    ld     a,(hl)
    out    (PORT_VDPData),a
    jp     title_frame_palette_alteration_complete
+:  ; For frames TITLE_MASTER_GAIDEN_FADE_OUT_FRAME to 255, fade the screen out.  
    ld     a,(title.anim_frame_counter)
    cp     TITLE_MASTER_GAIDEN_FADE_OUT_FRAME
    jp     c,+
    sub    TITLE_MASTER_GAIDEN_FADE_OUT_FRAME
    ld     (music_global_player_attenuation),a            ; Fade music.
    srl    a
    srl    a
    ld     e,a
    ld     hl,palette_data_title
    call   graphics_copy_faded_palettes_to_black
    jp     title_frame_palette_alteration_complete
+:
title_frame_palette_alteration_complete:

    call   title_vram_populate_nametable_menu_text

    call   vdp_registers_unblank_screen

    ei

    ; If the fade in has finished, allow the player to manipulate the menu.
    ld     a,(title.anim_frame_counter)
    cp     TITLE_MASTER_GAIDEN_FADE_IN_FRAME+15
    jp     nz,title_frame_menu_inactive
    ; Press start caption, or menu displayed?
    ld     a,(title.pressed_start)
    cp     0
    jp     nz,title_frame_handle_full_menu
    ld     a,(var_ControllerStatus.1.StatusHit)
    bit    CONTROLLER_BIT_BUTTON_1,a
    jp     nz,title_frame_handle_press_start_button_pressed
    bit    CONTROLLER_BIT_BUTTON_2,a
    jp     nz,title_frame_handle_press_start_button_pressed
    ; Nothing was pressed: return.
    jp     title_frame_menu_complete
title_frame_handle_press_start_button_pressed:
    ld     a,1
    ld     (title.pressed_start),a
    jp     title_frame_menu_complete
title_frame_handle_full_menu:
    ; The full menu is displayed. Handle up and down.
    ld     a,(var_ControllerStatus.1.StatusHit)
    bit    CONTROLLER_BIT_UP,a
    jp     nz,title_frame_handle_full_menu_move_cursor
    bit    CONTROLLER_BIT_DOWN,a          ; Down does the same as up! Don't tell anyone.
    jp     nz,title_frame_handle_full_menu_move_cursor
    jp     title_frame_handle_full_menu_handle_buttons
title_frame_handle_full_menu_move_cursor:
    ld     a,(title.menu_cursor_position) ; Toggle between 0 and 1.
    inc    a
    and    1
    ld     (title.menu_cursor_position),a
    ld     c,2                                      ; Play a sound!
    call   sound_force
    jp     title_frame_menu_complete
title_frame_handle_full_menu_handle_buttons:
    ; If we're on the top one, pressing button 1 starts the game.
    ld     a,(title.menu_cursor_position)
    cp     0
    jp     nz,title_frame_handle_full_menu_handle_controls_option
    ld     a,(var_ControllerStatus.1.StatusHit)
    bit    CONTROLLER_BIT_BUTTON_1,a
    jp     z,title_frame_menu_complete ; If we're on the top one, only button 1 does anything.
    ld     a,TITLE_MASTER_GAIDEN_FADE_OUT_FRAME
    ld     (title.anim_frame_counter),a
    ld     c,3                                      ; Play a super sound!
    call   sound_force
    jp     title_frame_menu_complete
title_frame_handle_full_menu_handle_controls_option:
    ; If we're on the bottom one, then pressing button 1, 2, left or right alters the controls.
    ld     a,(var_ControllerStatus.1.StatusHit)
    bit    CONTROLLER_BIT_BUTTON_1,a
    jp     nz,title_frame_handle_full_menu_toggle_controls
    bit    CONTROLLER_BIT_BUTTON_2,a
    jp     nz,title_frame_handle_full_menu_toggle_controls
    bit    CONTROLLER_BIT_LEFT,a
    jp     nz,title_frame_handle_full_menu_toggle_controls
    bit    CONTROLLER_BIT_RIGHT,a
    jp     nz,title_frame_handle_full_menu_toggle_controls
    jp     title_frame_menu_complete
title_frame_handle_full_menu_toggle_controls:
    ld     a,(game_persistent.controls_inverted) ; Toggle between 0 and 1.
    inc    a
    and    1
    ld     (game_persistent.controls_inverted),a
    ld     c,2                                      ; Play a sound!
    call   sound_force
    jp     title_frame_menu_complete


title_frame_menu_complete:
title_frame_menu_inactive:

    call   controller_update

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    ; Increment the animation counter.
    ld     a,(title.anim_frame_counter)
    cp     TITLE_MASTER_GAIDEN_FADE_IN_FRAME+15
    jp     z,+
    cp     255
    jp     z,game_init
    inc    a
    ld     (title.anim_frame_counter),a
+:

    jp     title_frame
    
title_vram_copy_tiles:
    ; Copy the gravity beam logo tile fragments into tiles 0-26
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|0
    SetVDPAddress_de_UNSAFE
    ld     bc,graphics_title_gravitybeamlogo_end-graphics_title_gravitybeamlogo
    ld     hl,graphics_title_gravitybeamlogo
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a                             ; Load first two bitplanes.
    ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    xor    a                                            ; Bitplane 3 is all zeroes.
    out    (PORT_VDPData),a
    xor    a                                            ; Bitplane 4 is all zeroes.
    out    (PORT_VDPData),a
    dec    bc
    dec    bc
    ld     a,b
    or     c
    jp     nz,-
    
    ; Construct a half blue tile in tile 108
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|(32*108)
    SetVDPAddress_de_UNSAFE

    ld     b,3*4 ; 3 pixel rows of all zero bitplanes.
    xor    a
    ; Colour 0 please. (Black)
-:  nop
    out    (PORT_VDPData),a
    djnz   -

    ld     c,%11111111 ; All active bits
    ld     d,%00000000 ; All inactive bits

    ; Colour 6 (%0110) please. (light blue stripe)
    ld     b,5
-:  xor    a
    out    (PORT_VDPData),a
    cpl
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    djnz   -

    ; Load the MASTER GAIDEN tiles.
;    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|(32*109)
;    SetVDPAddress_de_UNSAFE
    ld     hl,graphics_master_gaiden_letters_2bpp
    ld     b,288/2
    ; I've encoded it as a 2bpp planar tile thing. I'm going to expand that into a 4bpp palette using bitwise operations
    ; Source             Destination
    ; 0       00          0 0000
    ; 1       01   --->   4 0100
    ; 2       10   --->   5 0101
    ; 3       11   --->   6 0110
-:  ld     d,(hl)
    inc    hl
    ld     e,(hl)
    inc    hl

    ld     a,d
    cpl
    and    e
    out    (PORT_VDPData),a
    ld     a,d
    and    e
    out    (PORT_VDPData),a
    ld     a,d
    or     e
    out    (PORT_VDPData),a
    xor    a                                            ; Bitplane 4 is all zeroes.
    out    (PORT_VDPData),a
    djnz   -

    ; Load the greenfont.
    ld     hl,27
    call   vram_load_greenfont_tiles

    ; Decompress the greenwing large sprites into the sprite pattern data. Probably doesn't fit into a vblank ;)
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM+$2000
    SetVDPAddress_de_UNSAFE
    ld     bc,ha1_graphics_ending_greenwingsprites_4bpp_bin_fullsize
    ld     de,0
    ld     hl,ha1_graphics_ending_greenwingsprites_4bpp_bin_data
    call   ha1_decompress


    ret

title_vram_populate_nametable_gravity_beam_logo:
    ; Draw the Gravity Beam logo into the nametable
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*3)+5)*2)
    ld     de,graphics_title_gravitybeamlogo_map
    ld     c,8                                          ; C is vertical counter.
--: ld     b,23                                         ; B is horizontal counter.
    SetVDPAddress_UNSAFE
-:  ld     a,(de)                                       ; Load tile number from map.
    inc    de
    out    (PORT_VDPData),a
    xor    a                                            ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -
    push   de
    ld     de,32*2
    add    hl,de                                        ; Advance to next line of nametable.
    pop    de
    dec    c
    jp     nz,--

    ret

title_vram_populate_nametable_master_gaiden_string:
    ; Place the blue stripe tile horizontally across the centre of the screen.
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*13)+0)*2)
    SetVDPAddress_UNSAFE
    ld     b,32
-:  ld     a,108
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    djnz   -

    ld     b,32
-:  ld     a,108
    out    (PORT_VDPData),a
    ld     a,%00000100
    out    (PORT_VDPData),a
    djnz   -

    ; Place the MASTER GAIDEN string into the nametable.
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*13)+6)*2)
    SetVDPAddress_UNSAFE
    ld     de,graphics_title_master_gaiden_string_map
    ld     b,6                                          ; B is horizontal counter.
-:  ld     a,(de)                                       ; Load tile number from map.
    inc    de
    out    (PORT_VDPData),a
    xor    a                                            ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -

    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*13)+21)*2)
    SetVDPAddress_UNSAFE
    ld     b,6                                          ; B is horizontal counter.
-:  ld     a,(de)                                       ; Load tile number from map.
    inc    de
    out    (PORT_VDPData),a
    xor    a                                            ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -

    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*14)+6)*2)
    SetVDPAddress_UNSAFE
    ld     b,6                                          ; B is horizontal counter.
-:  ld     a,(de)                                       ; Load tile number from map.
    inc    de
    out    (PORT_VDPData),a
    xor    a                                            ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -

    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*14)+21)*2)
    SetVDPAddress_UNSAFE
    ld     b,6                                          ; B is horizontal counter.
-:  ld     a,(de)                                       ; Load tile number from map.
    inc    de
    out    (PORT_VDPData),a
    xor    a                                            ; Second byte of nametable entry is all zeroes.
    out    (PORT_VDPData),a
    djnz   -

    ret

; This is an array of tiles constructing the MASTER GAIDEN text from the tiles.
; Add on a constant representing the offset into the pattern RAM
; as we're not loading the pattern data into tile zero.
.equ MGO = 109

graphics_title_master_gaiden_string_map:
; Top line of MASTER
.db $00+MGO,$01+MGO, $02+MGO, $03+MGO, $04+MGO, $05+MGO
; Top line of GAIDEN
.db $06+MGO,$01+MGO, $03+MGO, $07+MGO, $04+MGO, $08+MGO
; Bottom line of MASTER
.db $09+MGO,$0A+MGO, $0B+MGO, $0C+MGO, $0D+MGO, $0E+MGO
; Bottom line of GAIDEN
.db $0F+MGO,$0A+MGO, $10+MGO, $11+MGO, $0D+MGO, $0A+MGO

title_frame_place_greenwing_sprite:
    ; Place the slightly smaller greenwing sprite onto the screen
    ; X positions and tile numbers
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+0*2 ; Place this into the appropriate memory location for Sprite 0
    SetVDPAddress_de_UNSAFE
    ld     b,48                                             ; B is sprites counter.
    ld     a,(title.greenwing_x)
    ld     c,a                                              ; C is X position cursor.
    ld     d,8                                              ; D counts number of sprites left on current row before 'carriage return'
    ld     hl,graphics_ending_greenwingsprites_map+128
-:  ld     a,(hl)                                           ; Load tile number from map.
    or     a                                                ; Compare against zero.
    jp     z,+++                                            ; Don't advance through the sprite attribute table if we're on a zero in the sprite tile map.
    ld     a,c
    cp     200
    jp     c,+                                              ; Only draw sprites if they're not underflowing:
    xor    a
+:  out    (PORT_VDPData),a                                 ; Write the X coordinate.
++: ld     a,(hl)                                           ; Load tile number from map. again.
    out    (PORT_VDPData),a                                 ; Write the tile number from the map
+++:ld     a,c
    add    a,8                                              ; Advance X position by 8
    dec    d                                                ; After placing the eight sprites, go back 64 pixels for the next row.
    jp     nz,+
    ld     d,8
    sub    64
+:  ld     c,a
    inc    hl
    djnz   -
    ; Y positions
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+0    ; Place this into the appropriate memory location for Sprite 0
    SetVDPAddress_de_UNSAFE
    ld     b,48                                             ; B is sprites counter.
    ld     a,(title.greenwing_y)                            ; C is Y position cursor.
    ld     c,a
    ld     d,8                                              ; D counts number of sprites left on current row before 'carriage return'
    ld     hl,graphics_ending_greenwingsprites_map+128
-:  ld     a,(hl)                                           ; Load tile number from map.
    or     a                                                ; Compare against zero.
    jp     z,+
    ld     a,c
    out    (PORT_VDPData),a
+:  dec    d                                                ; After placing the eight sprites, advance 8 pixels for the next row.
    jp     nz,+
    ld     d,8
    ld     a,c
    add    a,8
    ld     c,a
+:  inc    hl
    djnz   -

    ret
    
title_vram_populate_nametable_menu_text:
    ; We're either on the PRESS START BUTTON text, or the menu.

    ; Clear the area, before drawing the appropriate text.
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM|(((32*18)+0)*2)
    SetVDPAddress_UNSAFE
    xor    a
    ld     b,a
-:  nop
    out    (PORT_VDPData),a
    djnz   -

    ; Press start should be displayed?
    ld     a,(title.pressed_start)
    cp     0
    jp     nz,title_vram_populate_nametable_menu_text_display_full_menu
    ld     de,string_title_press_start_button
    ld     c,11
    ld     b,19
    call   vram_place_greenfont_string
    ret
title_vram_populate_nametable_menu_text_display_full_menu:
    ld     a,(title.menu_cursor_position)
    add    a,a
    add    a,18
    ld     b,a
    ld     c,5
    ld     de,string_title_cursor
    call   vram_place_greenfont_string

    ; Menu should be displayed?
    ld     de,string_title_start_game
    ld     c,7
    ld     b,18
    call   vram_place_greenfont_string
    ld     de,string_title_controls
    ld     c,7
    ld     b,20
    call   vram_place_greenfont_string
    ld     de,string_title_controls_2
    ld     c,17
    ld     b,21
    call   vram_place_greenfont_string
    ld     a,(game_persistent.controls_inverted)
    cp     0                 
    ld     de,string_title_controls_beam
    jp     z,+
    ld     de,string_title_controls_thrust
+:  ld     c,19
    ld     b,20
    call   vram_place_greenfont_string
    ld     a,(game_persistent.controls_inverted)
    cp     0
    ld     de,string_title_controls_thrust
    jp     z,+
    ld     de,string_title_controls_beam
+:  ld     c,19
    ld     b,21
    call   vram_place_greenfont_string

    ret

string_title_press_start_button:
.db "PRESS START",0

string_title_cursor:
.db '\',0

string_title_start_game:
.db "Start Game",0

string_title_controls:
.db "Controls: 1",0

string_title_controls_2:
.db "2",0

string_title_controls_thrust:
.db "THRUST",0

string_title_controls_beam:
.db "BEAM",0

; ========================================

win_fade_out_init:
    ; Set up the game state to start the winning animation:
    xor    a
    ld     (game.anim_frame_counter),a
    ld     (game.ingame_carrybox_flash_frame),a

    call   ingame_graphics_set_carrybox_sprite_palette

win_fade_out_frame:
    call   vblank_wait
    ; A new frame has begun!

    ; Disable the interrupts to allow for uninterrupted VDP access.
    ; Not that there ARE any interrupts that should happen here (vblank twice that rapidly? probably not.)
    di

    call   ingame_set_scroll_registers

    call   ingame_graphics_draw_new_rows_columns
    ld     a,(game.anim_frame_counter)
    srl    a
    srl    a
    srl    a
    ld     e,a
    ld     hl,palette_data_ingame
    call   graphics_copy_faded_palettes_to_black
    call   ingame_graphics_place_greenwing_sprite
    call   ingame_graphics_place_carrybox_sprite
    call   ingame_graphics_place_linkage_sprites
    call   ingame_graphics_copy_greenwing_frame_to_vram

    ei

    ; After drawing in the new columns, we update the 'old' registers.
    ld     hl,(game.camera_x)
    ld     (game.camera_old_x),hl
    ld     hl,(game.camera_y)
    ld     (game.camera_old_y),hl

    ; Increment the animation counter.
    ld     a,(game.anim_frame_counter)
    inc    a
    ld     (game.anim_frame_counter),a

    ; Fade music.
    sra    a
    ld     (music_global_player_attenuation),a

    ; This is all non-graphics stuff down here. So it's okay
    ; if we have a super long graphics-mangling frame, and then
    ; mess about with the controller and audio chip.

    call   controller_update

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    ; If the lose frame counter is above a certain threshold, move to the next stage of the animation.
    ld     a,(game.anim_frame_counter)
    cp     32
    jp     p,win_cinematic_0_init

    ; End of lose frame, wait for another vblank interrupt
    jp     win_fade_out_frame

; ========================================

win_cinematic_0_init:
    call   vblank_wait

    di

    ; Clear all tiles and stuff
    call   vram_clear_all

    call   vdp_registers_blank_screen
    
    ; Copy the space tiles to background tile pattern VRAM
    call   win_vram_copy_space_tiles

    ; Copy the green font into VRAM
    ld     hl,14
    call   vram_load_greenfont_tiles

    ; Set up the space name table
    call   win_vram_populate_nametable_space_tiles

    ; Decompress the greenwing large sprites into the sprite pattern data. Probably doesn't fit into a vblank ;)
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM+$2000
    SetVDPAddress_de_UNSAFE
    ld     bc,ha1_graphics_ending_greenwingsprites_4bpp_bin_fullsize
    ld     de,0
    ld     hl,ha1_graphics_ending_greenwingsprites_4bpp_bin_data
    call   ha1_decompress

    ; Copy the crate frames into VRAM (turns out we have enough VRAM space after all!)
    call   win_vram_copy_crate_sprite_tiles

    ; Enable Line Interrupts (by messing around with one of the overloaded VDP registers)
    ld     a,%00110100                         ; Enable HBlank interrupts. Hide leftmost eight pixels. Enable mode 4 SMS display.
    out    (PORT_VDPControl),a
    ld     a,0|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ld     hl,isr_win_cinematic_0
    ld     (var_isr_vector),hl                 ; Store the location of VBlankRoutine into RAM at VBlankRoutine_vector.

    ; Set X scrolling to zero.
    ld     a,0
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Set Y scrolling to zero.
    ld     a,0
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollY|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    call   vdp_registers_unblank_screen

    ei

    ; Clear the RAM copies of the two instances of the sprite attribute table for the two halves of the ship.
    ld     bc,64+128+64+128
    ld     hl,win_cinematic.win_cinematic_upper_sprite_at_y
-:  xor    a
    ld     (hl),a
    inc    hl
    dec    bc
    ld     a,b
    or     c
    jp     nz,-

    ; Full volume
    xor    a
    ld     (music_global_player_attenuation),a

    ld     (win_cinematic.win_cinematic_stage_number),a
    ld     (win_cinematic.win_cinematic_frame_counter),a

    ; Place greenwing sprite.
    ld     a,160
    ld     (win_cinematic.win_cinematic_gw_x),a
    ld     a,172
    ld     (win_cinematic.win_cinematic_gw_y),a

    ; Full volume
    xor    a
    ld     (music_global_player_attenuation),a

    ld     hl,music_fanfare
    call   music_select_song
    call   music_resume

win_cinematic_0_frame:
    ; The win cinematic is all uninteractive, so it's just a case of incrementing the counters, placing the stuff.
    call   vblank_wait

    di

    call   vdp_registers_blank_screen

    ; Set up hblank interrupts to display the lower half of the ship.
    ld     a,(win_cinematic.win_cinematic_gw_y)
    add    a,67+2
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_HBlankCounter|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Set the base address of the sprite AT to $1F00.
    ; Write to the sprite table base address VDP register and set the sprite AT address to $1F00
    ld     a,%00111111
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_SpriteATBase|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Copy the RAM copy of the upper sprite AT into $1F00
    ld     c,PORT_VDPData
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+0-$2000  ; Place this into the appropriate memory location for Sprite 0 in $1F00-based table.
    SetVDPAddress_de_UNSAFE
    ld     hl,win_cinematic.win_cinematic_upper_sprite_at_y
    ld     b,64                                                 ; 64 Y values.
    otir
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+0-$2000 ; Place this into the appropriate memory location for Sprite 0 in $1F00-based table.
    SetVDPAddress_de_UNSAFE
    ld     hl,win_cinematic.win_cinematic_upper_sprite_at_xn
    ld     b,128                                                ; 128 [XN] values.
    otir
    ; Copy the RAM copy of the lower sprite AT into $3F00
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+0        ; Place this into the appropriate memory location for Sprite 0 in $3F00-based table.
    SetVDPAddress_de_UNSAFE
    ld     hl,win_cinematic.win_cinematic_lower_sprite_at_y
    ld     b,64                                                 ; 64 Y values.
    otir
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+0       ; Place this into the appropriate memory location for Sprite 0 in $3F00-based table.
    SetVDPAddress_de_UNSAFE
    ld     hl,win_cinematic.win_cinematic_lower_sprite_at_xn
    ld     b,128                                                ; 128 [XN] values.
    otir

    call   vdp_registers_unblank_screen
    
    ei

    ; Of the top 64 tiles of the ship, 24 of them are BLANK! Which means we can make redundant
    ; entries in the 'top half' attribute table by skipping blank tiles and continuing to
    ; fill in entries until the AT is full. This should prevent that 'Ghastly Seam'
    ; in the middle of the ship.
    ; Populate the RAM copy of the Sprite AT for the upper half of the ship sprite.
    ; Y positions
    ; Use HL' to store destination address
    exx
    ld     hl,win_cinematic.win_cinematic_upper_sprite_at_y
    exx
    ld     b,64+8                                           ; B is sprites counter.
    ld     a,(win_cinematic.win_cinematic_gw_y); A is Y position cursor.
    ld     d,8                                              ; D counts number of sprites left on current row before 'carriage return'
    ld     hl,graphics_ending_greenwingsprites_map
-:  ld     c,(hl)                                           ; Load tile number from map to see if this is a real sprite or a 'hole'.
    inc    hl
    dec    c                                                ; Test for zero by decrementing.
    jp     m,+                                              ; Don't advance through the sprite attribute table if we're on a zero in the sprite tile map.
    exx
    ld     (hl),a                                           ; Store Y position in address from in HL'
    inc    hl
    exx
+:  dec    d                                                ; After placing the eight sprites, advance 8 pixels for the next row.
    jp     nz,+
    ld     d,8
    add    a,8
+:  djnz   -
    ; X positions and tile numbers
    exx
    ld     hl,win_cinematic.win_cinematic_upper_sprite_at_xn
    exx
    ld     b,64+8                                           ; B is sprites counter.
    ld     a,(win_cinematic.win_cinematic_gw_x)
    ld     c,a                                              ; C is X position cursor.
    ld     d,8                                              ; D counts number of sprites left on current row before 'carriage return'
    ld     hl,graphics_ending_greenwingsprites_map
-:  ld     a,(hl)                                           ; Load tile number from map to see if this is a real sprite or a 'hole'.
    or     a                                                ; Compare against zero.
    ld     a,c                                              ; X position back in A.
    jp     z,+                                              ; Don't advance through the sprite attribute table if we're on a zero in the sprite tile map.
    exx
    ld     (hl),a                                           ; Store X position in address from in HL'
    inc    hl
    exx
    ld     a,(hl)                                           ; Load tile number from map for output.
    exx
    ld     (hl),a                                           ; Store tile number in address from in HL'
    inc    hl
    exx
+:  inc    hl
    ld     a,c                                              ; X position back in A.
    add    a,8                                              ; Advance X position by 8
    dec    d                                                ; After placing the eight sprites, go back 64 pixels for the next row.
    jp     nz,+
    ld     d,8
    sub    64
+:  ld     c,a
    djnz   -
    ; Populate the RAM copy of the Sprite AT for the lower half of the ship sprite.
    ; Y positions
    ; Use HL' to store destination address
    exx
    ld     hl,win_cinematic.win_cinematic_lower_sprite_at_y
    exx
    ld     b,64                                             ; B is sprites counter.
    ld     a,(win_cinematic.win_cinematic_gw_y); A is Y position cursor.
    add    a,64
    ld     d,8                                              ; D counts number of sprites left on current row before 'carriage return'
    ld     hl,graphics_ending_greenwingsprites_map+64
-:  ld     c,(hl)                                           ; Load tile number from map to see if this is a real sprite or a 'hole'.
    inc    hl
    dec    c                                                ; Test for zero by decrementing.
    jp     m,+                                              ; Don't advance through the sprite attribute table if we're on a zero in the sprite tile map.
    exx
    ld     (hl),a                                           ; Store Y position in address from in HL'
    inc    hl
    exx
+:  dec    d                                                ; After placing the eight sprites, advance 8 pixels for the next row.
    jp     nz,+
    ld     d,8
    add    a,8
+:  djnz   -
    ; X positions and tile numbers
    exx
    ld     hl,win_cinematic.win_cinematic_lower_sprite_at_xn
    exx
    ld     b,64                                             ; B is sprites counter.
    ld     a,(win_cinematic.win_cinematic_gw_x)
    ld     c,a                                              ; C is X position cursor.
    ld     d,8                                              ; D counts number of sprites left on current row before 'carriage return'
    ld     hl,graphics_ending_greenwingsprites_map+64
-:  ld     a,(hl)                                           ; Load tile number from map to see if this is a real sprite or a 'hole'.
    or     a                                                ; Compare against zero.
    ld     a,c                                              ; X position back in A.
    jp     z,+                                              ; Don't advance through the sprite attribute table if we're on a zero in the sprite tile map.
    exx
    ld     (hl),a                                           ; Store X position in address from in HL'
    inc    hl
    exx
    ld     a,(hl)                                           ; Load tile number from map for output.
    exx
    ld     (hl),a                                           ; Store tile number in address from in HL'
    inc    hl
    exx
+:  inc    hl
    ld     a,c                                              ; X position back in A.
    add    a,8                                              ; Advance X position by 8
    dec    d                                                ; After placing the eight sprites, go back 64 pixels for the next row.
    jp     nz,+
    ld     d,8
    sub    64
+:  ld     c,a
    djnz   -

    ; Fade the palette from white downwards.
    ld     a,(win_cinematic.win_cinematic_frame_counter)
    cp     31
    jp     nc,+                                    ; Do not fade palette after frame 31.
    ld     b,a
    ld     a,31
    sub    b
    sra    a
    sra    a
    sra    a
    ld     e,a
    ld     hl,palette_data_win_cinematic
    call   graphics_copy_faded_palettes_to_white
    jp     ++
+:  ; Copy one of two sprite palette to CRAM depending on frame counter
    ld     hl,palette_data_win_cinematic_sprite_palette
    ld     e,0
    ld     a,(win_cinematic.win_cinematic_frame_counter)
    and    2
    jp     nz,+
    ld     hl,palette_data_win_cinematic_sprite_palette_engine_alt
+:  call   graphics_copy_faded_sprite_palette_to_white
++:
    ld     a,(win_cinematic.win_cinematic_frame_counter)
    and    1
    jp     nz,+
    ld     a,(win_cinematic.win_cinematic_gw_x)
    sub    1
    ld     (win_cinematic.win_cinematic_gw_x),a
    ld     a,(win_cinematic.win_cinematic_gw_y)
    sub    1
    ld     (win_cinematic.win_cinematic_gw_y),a
+:

    ld     a,(win_cinematic.win_cinematic_gw_y)
    sub    1
    ld     (win_cinematic.win_cinematic_gw_y),a

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    ld     a,(win_cinematic.win_cinematic_frame_counter)
    inc    a
    ld     (win_cinematic.win_cinematic_frame_counter),a
    cp     104
    jp     nz,win_cinematic_0_frame

win_cinematic_2_init:
    ld     a,2
    ld     (win_cinematic.win_cinematic_stage_number),a
    xor    a
    ld     (win_cinematic.win_cinematic_frame_counter),a

    ; Reposition the ship coordinates as it changes from one frame to another.
    ld     a,(win_cinematic.win_cinematic_gw_x)
    sub    15
    ld     (win_cinematic.win_cinematic_gw_x),a
    ld     a,(win_cinematic.win_cinematic_gw_y)
    add    a,20
    ld     (win_cinematic.win_cinematic_gw_y),a

    ld     a,100
    ld     (win_cinematic.win_cinematic_crate_x),a
    ld     a,192
    ld     (win_cinematic.win_cinematic_crate_y),a

    ; This vblank wait prevents glitches when the ship sprite transitions (on hardware...).
    call   vblank_wait

    di

    ; Disable Line Interrupts (by messing around with one of the overloaded VDP registers)
    ld     a,%00100100                         ; Hide leftmost eight pixels. Enable mode 4 SMS display.
    out    (PORT_VDPControl),a
    ld     a,0|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
    ; Set the HBlank counter to something big.
    ld     a,200
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_HBlankCounter|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Write to the sprite table base address VDP register and set the sprite AT address to $3F00
    ld     a,%01111111
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_SpriteATBase|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ld     hl,isr_vblank_only
    ld     (var_isr_vector),hl                 ; Store the location of VBlankRoutine into RAM at VBlankRoutine_vector.

    ei

win_cinematic_2_frame:
    ; The win cinematic is all uninteractive, so it's just a case of incrementing the counters, placing the stuff.
    call   vblank_wait

    di

    ; Place the second greenwing sprite onto the screen
    ld     a,(win_cinematic.win_cinematic_frame_counter)
    cp     150
    jp     nc,win_cinematic_2_clear_greenwing_sprite_at
    ; X positions and tile numbers
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+0*2 ; Place this into the appropriate memory location for Sprite 0
    SetVDPAddress_de_UNSAFE
    ld     b,48                                             ; B is sprites counter.
    ld     a,(win_cinematic.win_cinematic_gw_x)
    ld     c,a                                              ; C is X position cursor.
    ld     d,8                                              ; D counts number of sprites left on current row before 'carriage return'
    ld     hl,graphics_ending_greenwingsprites_map+128
-:  ld     a,(hl)                                           ; Load tile number from map.
    or     a                                                ; Compare against zero.
    jp     z,+++                                            ; Don't advance through the sprite attribute table if we're on a zero in the sprite tile map.
    ld     a,c
    cp     200
    jp     c,+                                              ; Only draw sprites if they're not underflowing:
    xor    a
+:  out    (PORT_VDPData),a                                 ; Write the X coordinate.
++: ld     a,(hl)                                           ; Load tile number from map. again.
    out    (PORT_VDPData),a                                 ; Write the tile number from the map
+++:ld     a,c
    add    a,8                                              ; Advance X position by 8
    dec    d                                                ; After placing the eight sprites, go back 64 pixels for the next row.
    jp     nz,+
    ld     d,8
    sub    64
+:  ld     c,a
    inc    hl
    djnz   -
    ; Y positions
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+0    ; Place this into the appropriate memory location for Sprite 0
    SetVDPAddress_de_UNSAFE
    ld     b,48                                             ; B is sprites counter.
    ld     a,(win_cinematic.win_cinematic_gw_y)             ; C is Y position cursor.
    ld     c,a
    ld     d,8                                              ; D counts number of sprites left on current row before 'carriage return'
    ld     hl,graphics_ending_greenwingsprites_map+128
-:  ld     a,(hl)                                           ; Load tile number from map.
    or     a                                                ; Compare against zero.
    jp     z,+
    ld     a,c
    out    (PORT_VDPData),a
+:  dec    d                                                ; After placing the eight sprites, advance 8 pixels for the next row.
    jp     nz,+
    ld     d,8
    ld     a,c
    add    a,8
    ld     c,a
+:  inc    hl
    djnz   -

    ; Copy one of two sprite palette to CRAM depending on frame counter to make engine trail flicker
    ld     hl,palette_data_win_cinematic_sprite_palette
    ld     e,0
    ld     a,(win_cinematic.win_cinematic_frame_counter)
    and    2
    jp     nz,+
    ld     hl,palette_data_win_cinematic_sprite_palette_engine_alt
+:  call   graphics_copy_faded_sprite_palette_to_white

    jp     win_cinematic_2_greenwing_sprite_done
win_cinematic_2_clear_greenwing_sprite_at:
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+0    ; Place this into the appropriate memory location for Sprite 0
    SetVDPAddress_de_UNSAFE
    ld     b,48                                             ; B is sprites counter.
    ld     a,200
-:  out    (PORT_VDPData),a
    djnz   -
    jp     win_cinematic_2_greenwing_sprite_done
win_cinematic_2_greenwing_sprite_done:
    
    ; Place the big crate sprite onto the screen.
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+37*2 ; Place this into the appropriate memory location for Sprite 37
    SetVDPAddress_de_UNSAFE
    ld     e,4                                              ; E contains width of the crate in sprites (depends on the current frame)
    ld     h,32                                             ; H contains the length of the 'carriage return'. (also depends on the current frame)
    ld     l,122                                            ; L is tile number (also depends on the current frame)
    ld     a,(win_cinematic.win_cinematic_crate_x)
    ld     c,a                                              ; C is X position cursor.
    ld     a,(win_cinematic.win_cinematic_crate_y)
    and    16
    jp     nz,+                                             ; As the crate spins, it changes from a 4x3 rectangle to a 3x4 and its position changes slightly.
    ld     e,3
    ld     h,24
    ld     l,12+122
    inc    c
    inc    c
    inc    c
    inc    c
+:

    ld     b,12                                             ; B is sprites counter.
    ld     d,e                                              ; D counts number of sprites left on current row before 'carriage return'
-:  ld     a,c                                              ; Load X coordinate.
    out    (PORT_VDPData),a                                 ; Write the X coordinate.
    ld     a,l                                              ; Load tile number from map.
    inc    l
    out    (PORT_VDPData),a                                 ; Write the tile number from the map
    ld     a,c
    add    a,8                                              ; Advance X position by 8
    dec    d                                                ; After placing one row of sprites, go back 32 pixels for the next row.
    jp     nz,+
    ld     d,e
    sub    h
+:  ld     c,a
    djnz   -
    ; Y positions
    push   de
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+37   ; Place this into the appropriate memory location for Sprite 37
    SetVDPAddress_de_UNSAFE
    pop    de
    ld     b,12                                             ; B is sprites counter.
    ld     a,(win_cinematic.win_cinematic_crate_y)          ; A is Y position cursor.
    bit    4,a
    jp     nz,+
    sub    5
+:
    ld     d,e                                              ; D counts number of sprites left on current row before 'carriage return'
-:  out    (PORT_VDPData),a
    dec    d                                                ; After placing one row of sprites, advance 8 pixels for the next row.
    jp     nz,+
    ld     d,e
    add    a,8
+:  djnz   -

    ; Clear the unused sprites.
    ld     b,15                                             ; B is sprites counter.
    ld     a,200
-:  out    (PORT_VDPData),a
    djnz   -

    ; Near the end make the screen fade to BANG.
    ld     a,(win_cinematic.win_cinematic_frame_counter)
    cp     239
    jp     c,+
    sub    239
    ld     e,a
    srl    e
    srl    e
    ld     hl,palette_data_win_cinematic_explode_alt
    call   graphics_copy_faded_palettes_to_white
    jp     win_cinematic_2_palette_alteration_complete
+:  ; At given frame, set crate palette to EXPLODEY
    ld     a,(win_cinematic.win_cinematic_frame_counter)
    cp     225
    jp     nz,win_cinematic_2_palette_alteration_complete
    ld     hl,palette_data_win_cinematic_sprite_palette_explode_alt
    ld     e,0
    call   graphics_copy_faded_sprite_palette_to_white
win_cinematic_2_palette_alteration_complete:

    ei

    ld     a,(win_cinematic.win_cinematic_frame_counter)
    ld     b,a
    and    2
    jp     nz,+
    ld     a,(win_cinematic.win_cinematic_gw_y)
    sub    1
    ld     (win_cinematic.win_cinematic_gw_y),a
+:
    ld     a,(win_cinematic.win_cinematic_gw_x)
    sub    1
    ld     (win_cinematic.win_cinematic_gw_x),a

    ld     a,b
    cp     95                                              ; After frame X, the crate's motion slows.
    jp     nc,win_cinematic_2_crate_motion_slow
    and    1
    jp     nz,+
    ld     a,(win_cinematic.win_cinematic_crate_x)
    add    a,1
    ld     (win_cinematic.win_cinematic_crate_x),a
+:  ld     a,(win_cinematic.win_cinematic_crate_y)
    sub    1
    ld     (win_cinematic.win_cinematic_crate_y),a
    jp     win_cinematic_2_crate_motion_complete
win_cinematic_2_crate_motion_slow:
    cp     165                                             ; After frame X, the crate's motion slows further.
    jp     nc,win_cinematic_2_crate_motion_slow2
    and    1
    jp     nz,win_cinematic_2_crate_motion_complete
    ld     a,b
    and    2
    jp     nz,+
    ld     a,(win_cinematic.win_cinematic_crate_x)
    add    a,1
    ld     (win_cinematic.win_cinematic_crate_x),a
+:  ld     a,(win_cinematic.win_cinematic_crate_y)
    sub    1
    ld     (win_cinematic.win_cinematic_crate_y),a
    jp     win_cinematic_2_crate_motion_complete
win_cinematic_2_crate_motion_slow2:
    and    3
    jp     nz,win_cinematic_2_crate_motion_complete
    ld     a,b
    and    4
    jp     nz,+
    ld     a,(win_cinematic.win_cinematic_crate_x)
    add    a,1
    ld     (win_cinematic.win_cinematic_crate_x),a
+:  ld     a,(win_cinematic.win_cinematic_crate_y)
    sub    1
    ld     (win_cinematic.win_cinematic_crate_y),a
win_cinematic_2_crate_motion_complete:

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    ld     a,(win_cinematic.win_cinematic_frame_counter)
    inc    a
    ld     (win_cinematic.win_cinematic_frame_counter),a
    cp     255
    jp     nz,win_cinematic_2_frame

win_cinematic_3_init:
    ld     a,3
    ld     (win_cinematic.win_cinematic_stage_number),a
    xor    a
    ld     (win_cinematic.win_cinematic_frame_counter),a

    call   vblank_wait
    di
    
    call   vram_hide_all_sprites

    ; Copy the bombleds to VRAM tiles (256+) 7-20
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|$2000+(32*7)
    SetVDPAddress_de_UNSAFE
    ld     bc,ha1_graphics_bombleds_bin_fullsize
    ld     de,0
    ld     hl,ha1_graphics_bombleds_bin_data
    call   ha1_decompress

    ei

win_cinematic_3_frame:
    ; The win cinematic is all uninteractive, so it's just a case of incrementing the counters, placing the stuff.
    call   vblank_wait

    di

    call   vdp_registers_blank_screen

    ; Fade out from BANG.
    ld     a,(win_cinematic.win_cinematic_frame_counter)
    cp     30
    jp     c,+
    sub    30
    cp     64
    jp     nc,+
    ld     e,a
    srl    e
    srl    e
    srl    e
    srl    e
    ld     a,3
    sub    e
    ld     e,a
    ld     hl,palette_data_win_cinematic
    call   graphics_copy_faded_palettes_to_white
+:

    ld     a,(win_cinematic.win_cinematic_frame_counter)
    cp     200
    jp     nz,win_cinematic_3_rank_dont_print_yet
    call   win_graphics_place_bombled_sprites
    ld     de,string_ending_1
    ld     c,8
    ld     b,2
    call   vram_place_greenfont_string
    ld     de,string_ending_2
    ld     c,7
    ld     b,4
    call   vram_place_greenfont_string
    ld     de,string_ending_3
    ld     c,4
    ld     b,5
    call   vram_place_greenfont_string
    ld     de,string_ending_time_left
    ld     c,7
    ld     b,8
    call   vram_place_greenfont_string
    ld     de,string_ending_see_you
    ld     c,7
    ld     b,16
    call   vram_place_greenfont_string
    ; Print a different set of strings depending on the player's rank.
    ld     a,(game_persistent.ingame_bombled_minutes_counter)
    cp     4
    jp     nz,+             
    ; 4:00:00 to 4:59.98
    ld     de,string_rank_0_line_0
    ld     c,1
    ld     b,11
    call   vram_place_greenfont_string
    ld     de,string_rank_0_line_1
    ld     c,1
    ld     b,13
    call   vram_place_greenfont_string
    ld     de,string_rank_0_line_2
    ld     c,1
    ld     b,14
    call   vram_place_greenfont_string
    jp     win_cinematic_3_rank_printed
+:  cp     3
    jp     nz,+
    ; 3:00:00 to 3:59.98
    ld     de,string_rank_1_line_0
    ld     c,1
    ld     b,11
    call   vram_place_greenfont_string
    ld     de,string_rank_1_line_1
    ld     c,1
    ld     b,13
    call   vram_place_greenfont_string
    ld     de,string_rank_1_line_2
    ld     c,1
    ld     b,14
    call   vram_place_greenfont_string
    jp     win_cinematic_3_rank_printed
+:  cp     2
    jp     nz,+             
    ; 2:00:00 to 2:59.98
    ld     de,string_rank_2_line_0
    ld     c,1
    ld     b,11
    call   vram_place_greenfont_string
    ld     de,string_rank_2_line_1
    ld     c,1
    ld     b,13
    call   vram_place_greenfont_string
    ld     de,string_rank_2_line_2
    ld     c,1
    ld     b,14
    call   vram_place_greenfont_string
    jp     win_cinematic_3_rank_printed
+:  cp     1
    jp     nz,+             
    ; 1:00:00 to 1:59.98
    ld     de,string_rank_3_line_0
    ld     c,1
    ld     b,11
    call   vram_place_greenfont_string
    ld     de,string_rank_3_line_1
    ld     c,1
    ld     b,13
    call   vram_place_greenfont_string
    ld     de,string_rank_3_line_2
    ld     c,1
    ld     b,14
    call   vram_place_greenfont_string
    jp     win_cinematic_3_rank_printed
+:  ld     a,(game_persistent.ingame_bombled_seconds_counter_h)
    cp     0
    jp     nz,+
    ld     a,(game_persistent.ingame_bombled_seconds_counter_l)
    cp     5  ; The last five seconds.
    jp     nc,+
    ld     de,string_rank_5_line_0
    ld     c,1
    ld     b,11
    call   vram_place_greenfont_string
    ld     de,string_rank_5_line_1
    ld     c,1
    ld     b,13
    call   vram_place_greenfont_string
    ld     de,string_rank_5_line_2
    ld     c,1
    ld     b,14
    call   vram_place_greenfont_string
    jp     win_cinematic_3_rank_printed
+:  ; 0:05:00 to 0:59.98
    ld     de,string_rank_4_line_0
    ld     c,1
    ld     b,11
    call   vram_place_greenfont_string
    ld     de,string_rank_4_line_1
    ld     c,1
    ld     b,13
    call   vram_place_greenfont_string
    ld     de,string_rank_4_line_2
    ld     c,1
    ld     b,14
    call   vram_place_greenfont_string
    jp     win_cinematic_3_rank_printed
win_cinematic_3_rank_dont_print_yet:
win_cinematic_3_rank_printed:

    call   vdp_registers_unblank_screen

    ei

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    ld     a,(win_cinematic.win_cinematic_frame_counter)
    inc    a
    ld     (win_cinematic.win_cinematic_frame_counter),a
    cp     255
    jp     nz,win_cinematic_3_frame

    ld     a,250
    ld     (win_cinematic.win_cinematic_frame_counter),a
    jp     win_cinematic_3_frame

;etc

.endasm
Real characters
0123456789:;<=>?
@ABCDEFGHJIKLMNO
PQRSTUVWXYZ[\]^_
`abcdefghijklmno
pqrstuvwxyz{|}~nbsp (char $7F CHAR_FULLSTOP)

Greenfont output

0123456789:;'!"?
ABCDEFGHIJKLMNO
PQRSTUVWXYZ[]+-
_abcdefghijklmno
pqrstuvwxyz[\/,.
.asm

string_ending_1:
.asc "Thank you, Pilot!"
.db 0

string_ending_2:
.asc "You have saved Mars"
.db 0

string_ending_3:
.asc "from certain destruction."
.db 0

.db "Or maybe you just opened the ROM up in a hex editor instead."

string_ending_time_left:
.asc "TIME LEFT:"
.db 0

string_ending_see_you:
.asc "See You Next Game!"
.db 0

string_rank_0_line_0:
    ;0123456789012345678901234567890
.asc "Rank: Undisputed Master of Mars"
.db 0
string_rank_0_line_1:
    ;0123456789012345678901234567890
.asc " We would like to offer you the"
.db 0
string_rank_0_line_2:
    ;0123456789012345678901234567890
.asc " position of President of Mars."
.db 0

string_rank_1_line_0:
    ;0123456789012345678901234567890
.asc "     Rank: Magnificent Ace    "
.db 0
string_rank_1_line_1:
    ;0123456789012345678901234567890
.asc "A joy to watch! Come planetside"
.db 0
string_rank_1_line_2:
    ;0123456789012345678901234567890
.asc " sometime, we owe you a drink! "
.db 0

string_rank_2_line_0:
    ;0123456789012345678901234567890
.asc "    Rank: Confident Adept      "
.db 0
string_rank_2_line_1:
    ;0123456789012345678901234567890
.asc "  Thanks for the help, pilot! "
.db 0
string_rank_2_line_2:
    ;0123456789012345678901234567890
.asc "   We all owe you our lives.  "
.db 0

string_rank_3_line_0:
    ;0123456789012345678901234567890
.asc "        Rank: Slowpoke         "
.db 0
string_rank_3_line_1:
    ;0123456789012345678901234567890
.asc "You had us worried for a second"
.db 0
string_rank_3_line_2:
    ;0123456789012345678901234567890
.asc "but we had faith in you, pilot!"
.db 0

string_rank_4_line_0:
    ;0123456789012345678901234567890
.asc "   Rank: Last Minute <Hero<    "
.db 0
string_rank_4_line_1:
    ;0123456789012345678901234567890
.asc " You almost got us all killed! "
.db 0
string_rank_4_line_2:
    ;0123456789012345678901234567890
.asc "  We won't ask for you again!  "
.db 0

string_rank_5_line_0:
    ;0123456789012345678901234567890
.asc "      Rank: Lucky Bastard      "
.db 0
string_rank_5_line_1:
    ;0123456789012345678901234567890
.asc "Not that we're not thankful but"
.db 0
string_rank_5_line_2:
    ;0123456789012345678901234567890
.asc " you do owe us new underpants. "
.db 0

;.db "Rank: Hacker Extraordinare, mate."," You're like some grotesque Carmack-Dijkstra hybrid."

; ========================================

win_vram_populate_nametable_space_tiles:
    ld     de,VDPCommand_VRAMWrite|VRAM_NametableRAM
    SetVDPAddress_de_UNSAFE
    ld     bc,32*20                           ; BC is counter as we hit every tile on the screen.
    ; Put some random stars down.
    ld     hl,ha1_graphics_gaiden_ingame_tiles_bin_data
-:  ld     a,(hl)
    inc    hl
    add    a,l
    cp     254
    jp     c,+
    ld     a,2
    out    (PORT_VDPData),a
    jp     ++
+:  cp     245
    jp     c,+
    ld     a,1
    out    (PORT_VDPData),a
    jp     ++
+:  xor    a
    out    (PORT_VDPData),a
++: xor    a                                  ; zero for second tile byte.
    out    (PORT_VDPData),a
    dec    bc
    ld     a,b
    or     c
    jp     nz,-
    
.equ WIN_VRAM_PLANET_Y_START = 17

    ld     de,VDPCommand_VRAMWrite|VRAM_NametableRAM+(32*WIN_VRAM_PLANET_Y_START)*2
    SetVDPAddress_de_UNSAFE
    ld     b,32                                  ; B is tile counter as we go along the screen.
    ; Draw the various layers of the purple fuzz:
-:  ld     a,3
    out    (PORT_VDPData),a
    xor    a                                  ; zero for second tile byte.
    out    (PORT_VDPData),a
    djnz   -
    ld     b,32
-:  ld     a,5
    out    (PORT_VDPData),a
    xor    a                                  ; zero for second tile byte.
    out    (PORT_VDPData),a
    djnz   -
    ld     b,32*(24-(2+WIN_VRAM_PLANET_Y_START))
-:  ld     a,8
    out    (PORT_VDPData),a
    xor    a                                  ; zero for second tile byte.
    out    (PORT_VDPData),a
    djnz   -

    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM+(32*WIN_VRAM_PLANET_Y_START+1)*2
    SetVDPAddress_UNSAFE
    ld     de,win_vram_planet_size_tilemapping
    ld     c,4                                    ; C is Y counter into below
--: ld     b,7                                    ; B is X counter into below rectangle
-:  ld     a,(de)                                 ; Read tile number from below array
    inc    de
    out    (PORT_VDPData),a
    ld     a,%00000010                            ; Inverted horizontally.
    out    (PORT_VDPData),a
    djnz   -
    push   bc
    ld     bc,(32)*2                              ; Advance VRAM cursor to next line.
    add    hl,bc
    SetVDPAddress_UNSAFE
    pop    bc
    dec    c
    jp     nz,--

    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM+(32*WIN_VRAM_PLANET_Y_START+25)*2
    SetVDPAddress_UNSAFE
    ld     de,win_vram_planet_size_tilemapping_reversed
    ld     c,4                                    ; C is Y counter into below
--: ld     b,7                                    ; B is X counter into below rectangle
-:  ld     a,(de)                                 ; Read tile number from below array
    inc    de
    out    (PORT_VDPData),a
    xor    a                                      ; zero for second tile byte.
    out    (PORT_VDPData),a
    djnz   -
    push   bc
    ld     bc,(32)*2                              ; Advance VRAM cursor to next line.
    add    hl,bc
    SetVDPAddress_UNSAFE
    pop    bc
    dec    c
    jp     nz,--

    ; Redraw the sizes of the planet atmosphere to give it its curvature.
    ret

; This is the layout of the tiles that give the planet atmosphere its curvature.
win_vram_planet_size_tilemapping:
.db 0, 0, 0, 0, 0, 0, 4
.db 0, 7, 3, 6, 6, 5, 5
.db 6,13,12,11,10, 9, 8
.db 9, 8, 8, 8, 8, 8, 8

; This is the layout of the tiles that give the planet atmosphere its curvature (inverted)
win_vram_planet_size_tilemapping_reversed:
.db 4, 0, 0, 0, 0, 0, 0
.db 5, 5, 6, 6, 3, 7, 0
.db 8, 9,10,11,12,13, 6
.db 8, 8, 8, 8, 8, 8, 9

win_vram_copy_crate_sprite_tiles:
    ; Copy the ending crate sprite frames to VRAM tiles (256+X)
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|$2000+(32*122)
    SetVDPAddress_de_UNSAFE
    ld     bc,ha1_graphics_ending_crate_twoframes_bin_fullsize
    ld     de,0
    ld     hl,ha1_graphics_ending_crate_twoframes_bin_data
    call   ha1_decompress

    ret

win_vram_copy_space_tiles:
    ; Copy the ending space tiles to VRAM tiles 1-...
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|$0000+32
    SetVDPAddress_de_UNSAFE
    ld     hl,graphics_ending_space_tiles
    ld     b,(graphics_ending_space_tiles_end-graphics_ending_space_tiles)/2
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    ld     a,(hl)
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    inc    hl
    out    (PORT_VDPData),a
    djnz   -

    ret

lose_fade_out_init:
    ; Set up the game state to start the losing animation:
    xor    a

    ld     (game.player_link_established),a

    ld     a,1
    ld     (game.anim_frame_counter),a

    ld     a,255
    ld     (game.ingame_carrybox_flash_frame),a

    call   ingame_graphics_set_carrybox_sprite_palette
    
    ; Play the kaboom sound effect 'song'.
    call   sound_release_all

    ld     hl,music_explosionbeep
    call   music_select_song
    call   music_resume

lose_fade_out_frame:
    call   vblank_wait
    ; A new frame has begun!

    ; Disable the interrupts to allow for uninterrupted VDP access.
    ; Not that there ARE any interrupts that should happen here (vblank twice that rapidly? probably not.)
    di

    call   ingame_set_scroll_registers

    call   ingame_graphics_draw_new_rows_columns
    call   lose_fade_out_graphics_draw_explosion_bar
    ld     a,(game.anim_frame_counter)
    srl    a
    srl    a
    ld     e,a                                             ; E goes from 0 - 3 as A goes from 0 - 15
    ld     hl,palette_data_ingame
    call   graphics_copy_faded_palettes_to_white
    call   ingame_graphics_set_carrybox_sprite_palette
;    call   ingame_graphics_place_greenwing_sprite
;    call   ingame_graphics_place_carrybox_sprite
;    call   ingame_graphics_place_linkage_sprites
;    call   ingame_graphics_copy_greenwing_frame_to_vram

    ei

    ; After drawing in the new columns, we update the 'old' registers.
    ld     hl,(game.camera_x)
    ld     (game.camera_old_x),hl
    ld     hl,(game.camera_y)
    ld     (game.camera_old_y),hl

    ; Increment the animation counter.
    ld     a,(game.anim_frame_counter)
    inc    a
    ld     (game.anim_frame_counter),a

    ; This is all non-graphics stuff down here. So it's okay
    ; if we have a super long graphics-mangling frame, and then
    ; mess about with the controller and audio chip.

    call   controller_update

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    ; If the lose frame counter is above a certain threshold, move to the next stage of the animation.
    ld     a,(game.anim_frame_counter)
    cp     16
    jp     nz,lose_fade_out_frame

lose_init:
    call   vblank_wait

    di

    call   vdp_registers_blank_screen
    ; Clear all tiles and stuff
    call   vram_clear_all
    ; Fill the nametable with random assignments from the above tiles. This is the static background on the game over screen
    call   lose_vram_populate_nametable_with_static_tiles
    ; Copy random static into the first ten tiles of VRAM
    call   lose_vram_copy_static_tiles
    ; Copy the contact lost text tiles into VRAM
    call   lose_vram_copy_contact_lost_tiles
    ; Copy the green font into VRAM
    ld     hl,39
    call   vram_load_greenfont_tiles
    ; Reset the frame counter.
    xor    a
    ld     (lose.anim_frame_counter),a

    ; Set Y scrolling to zero.
    ld     a,0
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollY|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    call   vdp_registers_unblank_screen

    ei

    ; It's the "Oh God, What's Going On." wait!!
    ; Not as long as it used to be, the huffman decoding extends this a bit :P
    ld     b,60

-:  call   vblank_wait

    push   bc

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    pop    bc
    djnz   -

.equ LOSE_CONTACT_LOST_SECTION_Y_SIZE = 64
.equ LOSE_CONTACT_LOST_SECTION_Y_TOP  = 64

lose_frame:
    call   vblank_wait
    ; A new frame has begun!

    ; Disable the interrupts to allow for uninterrupted VDP access.
    ; Not that there ARE any interrupts that should happen here (vblank twice that rapidly? probably not.)
    di

    ; If we're on this frame, then install our interrupt handler to stop the middle of the screen scrolling.
    ld     a,(lose.anim_frame_counter)
    cp     157
    jp     nz,+
    ; Enable Line Interrupts (by messing around with one of the overloaded VDP registers)
    ld     a,%00110100                    ; Enable HBlank interrupts. Hide leftmost eight pixels. Enable mode 4 SMS display.
    out    (PORT_VDPControl),a
    ld     a,0|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ; Set up HBlank interrupts.
    ld     a,0                            ; A hblank every line, if you please.
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_HBlankCounter|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ld     hl,isr_lose_contact_lost
    ld     (var_isr_vector),hl            ; Store the location of VBlankRoutine into RAM at VBlankRoutine_vector.

    ; Blank the middle few rows of the nametable in preparation for the Contact Lost text.
    ld     bc,32*(LOSE_CONTACT_LOST_SECTION_Y_SIZE/8)
    ld     de,VDPCommand_VRAMWrite|VRAM_NametableRAM+(LOSE_CONTACT_LOST_SECTION_Y_TOP/8)*2*32
    SetVDPAddress_de_UNSAFE
-:  xor    a
    out    (PORT_VDPData),a
    dec    bc                             ; Decrement index instead of using nop.
    out    (PORT_VDPData),a
    ld     a,b
    or     c
    jp     nz,-

    call   lose_vram_populate_nametable_with_contact_lost_tiles

    ld     de,string_press_button_to_restart
    ld     b,14
    ld     c,5
    call   vram_place_greenfont_string
+:

    ei

    ; Fade to the regular static palette, when anim_frame_counter is between 0 and 32.
    ld     a,(lose.anim_frame_counter)
    ld     b,a
    ld     a,31
    sub    b
    jp     c,+
    srl    a
    srl    a
    srl    a
    ld     e,a                                              ; E goes from 3 - 0 as A goes 0 - 31
    ld     hl,palette_data_lose_static
    call   graphics_copy_faded_palettes_to_white
+:

    ; During the interactive period, allow the player to press a button to trigger the transition to black.
    ld     a,(lose.anim_frame_counter)
    cp     158
    jp     z,+
    cp     159
    jp     z,+
    jp     ++
+:
    ld     a,(var_ControllerStatus.1.StatusHit)
    bit    CONTROLLER_BIT_BUTTON_1,a
    jp     nz,+
    bit    CONTROLLER_BIT_BUTTON_2,a
    jp     nz,+
    bit    CONTROLLER_BIT_PAUSE,a                            ; AHAHAHAH yes it's a button too.
    jp     nz,+
    jp     ++                                                ; No buttons, no transition.
+:
    ld     c,3                                      ; Play a super sound!
    call   sound_force
    ld     a,200
    ld     (lose.anim_frame_counter),a
++:

    ; Fade to black when anim_frame_counter is between 200 and 216.
    ld     a,(lose.anim_frame_counter)
    sub    200
    jp     c,+
    srl    a
    srl    a
    ld     e,a                                              ; E goes from 0 - 3 as A goes 0 - 15
    ld     hl,palette_data_lose_static
    call   graphics_copy_faded_palettes_to_black
+:

    ; During the interactive period, loop the anim_frame_counter
    ; between 158-159 to keep the background moving.
    ld     a,(lose.anim_frame_counter)
    inc    a
    cp     160
    jp     nz,+
    ld     a,158                                            ; Keep cycling to this value.
+:  ld     (lose.anim_frame_counter),a

    ; Only do the following every other frame.
    ld     a,(lose.anim_frame_counter)
    bit    0,a
    jp     nz,+
    ; Monkey with the scroll registers to make the static move.
    ld     b,43
    ld     a,(lose.scroll_register_x)
    sub    b
    ld     (lose.scroll_register_x),a
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
+:

    call   controller_update

    call   music_tick
    call   instruments_tick
    call   percussion_tick
    call   sound_tick

    ; Exit to the next phase when the anim_frame_counter is 215.
    ld     a,(lose.anim_frame_counter)
    cp     215
    jp     nz,+
    call   music_stop
    call   percussion_tick
    jp     game_init
+:

    ; End of lose frame, wait for another vblank interrupt
    jp     lose_frame


; ========================================

string_press_button_to_restart:
.db  "PRESS BUTTON TO RESTART"
.db 0


; Load the greenfont tiles into the tile number stored in HL.
vram_load_greenfont_tiles:
    ; Construct offset into VRAM in HL.
    ld     (greenfont_base_tile_number),hl
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl                                         ; HL = 32 * tile number
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM
    add    hl,de
    SetVDPAddress_UNSAFE
    ld     hl,graphics_greenfont
    ld     bc,(graphics_greenfont_end-graphics_greenfont)/2
-:  ld     e,(hl)                                        ; Load the two source pixel rows into de. E contains least significant bit pixel (DE = ML)
    inc    hl
    ld     d,(hl)
    inc    hl
    ; I've encoded the greenfont as a 2bpp planar tile thing. I'm going to expand that into a 4bpp palette using bitwise operations
    ; Source             Destination
    ; 0       00          0 0000
    ; 1       01   --->   8 1000
    ; 2       10          B 1011
    ; 3       11          C 1100

    ; Least significant output bit = M & not L
    ld     a,e
    cpl
    and    d
    out    (PORT_VDPData),a
    ; Second output bit = same as above!
    out    (PORT_VDPData),a
    ; Third output bit = M & L
    ld     a,e
    and    d
    out    (PORT_VDPData),a
    ; Fourth output bit = (M or L)
    ld     a,e
    or     d
    out    (PORT_VDPData),a        
    dec    bc                                 
    ld     a,b
    or     c
    jp     nz,-
    ret

; Load the greenfont tiles into the tile number stored in HL.
; Use an alternate colour decoding to allow us to have the font
; coexist with some other graphic. (Used on the plot_2 screen with the big greenwing)
vram_load_greenfont_tiles_alternate_plot_2:
    ; Construct offset into VRAM in HL.
    ld     (greenfont_base_tile_number),hl
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl                                         ; HL = 32 * tile number
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM
    add    hl,de
    SetVDPAddress_UNSAFE
    ld     hl,graphics_greenfont
    ld     bc,(graphics_greenfont_end-graphics_greenfont)/2
-:  ld     e,(hl)                                        ; Load the two source pixel rows into de. E contains least significant bit pixel (DE = ML)
    inc    hl
    ld     d,(hl)
    inc    hl
    ; I've encoded the greenfont as a 2bpp planar tile thing. I'm going to expand that into a 4bpp palette using bitwise operations
    ; Source             Destination
    ; 0       00          1 0001
    ; 1       01   --->   1 0001
    ; 2       10          3 0011
    ; 3       11          4 0100

    ; Least significant output bit = not (M and L)
    ld     a,e
    and    d
    cpl
    out    (PORT_VDPData),a
    ; Second output bit = M and not L
    ld     a,e
    cpl
    and    d
    out    (PORT_VDPData),a
    ; Third output bit = M and L
    ld     a,e
    and    d
    out    (PORT_VDPData),a
    ; Fourth output bit = zero
    xor    a
    out    (PORT_VDPData),a
    dec    bc                                 
    ld     a,b
    or     c
    jp     nz,-
    ret

; Load the string of text pointed to in DE at screen coordinates B,C (c=x, b=y)
vram_place_greenfont_string:
    ; Construct offset into VRAM in HL.
    ld     h,0
    ld     l,b
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl                                          ; HL = 32 * Y
    ld     b,0                                            ; BC = 16-bit version of X
    add    hl,bc                                          ; HL = 32 * Y + X
    add    hl,hl                                          ; HL = 64 * Y + 2 * X
    ld     bc,VDPCommand_VRAMWrite|VRAM_NametableRAM
    add    hl,bc
    SetVDPAddress_UNSAFE
    ld     hl,(greenfont_base_tile_number)
    ld     bc,'0'                                         ; Subtract '0' because that's the first printable character.
    xor    a
    sbc    hl,bc
    ld     b,h
    ld     c,l
-:  ld     a,(de)
    cp     0
    ret    z                                              ; This is the termination condition for this loop: reading a zero character.
    inc    de
    cp     ' '
    jp     nz,+
    ld     a,0                                            ; Spaces are tile zero:
    jp     vram_place_greenfont_string_ready_to_print_character
+:
    add    a,c                                            ; Add on the base tile number (ignore that it's two byte. I can't be bothered with a sprite tile version now.)
vram_place_greenfont_string_ready_to_print_character:
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    jp     -

; Print the next character in the currently targeted greenfont charplace string.
vram_place_greenfont_charplace_place_next:
    ; Construct offset into VRAM in HL.
    ld     a,(vram_greenfont_charplace_tile_cursor_y)
    ld     h,0
    ld     l,a
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl
    add    hl,hl                                          ; HL = 32 * Y
    ld     a,(vram_greenfont_charplace_tile_cursor_x)
    ld     b,0                                            ; BC = 16-bit version of X
    ld     c,a
    add    hl,bc                                          ; HL = 32 * Y + X
    add    hl,hl                                          ; HL = 64 * Y + 2 * X
    ld     bc,VDPCommand_VRAMWrite|VRAM_NametableRAM
    add    hl,bc
    SetVDPAddress_UNSAFE
    ; We now have targeted the destination tile.
    ; Read the next character from the currently targeted greenfont charplace string.
    ld     hl,(vram_greenfont_charplace_string_ptr)
    ld     a,h
    or     l
    ret    z                                              ; Do nothing if the string ptr is all zero.
    ld     a,(hl)
    and    a
    jp     nz,+                                           ; If we read a zero, invalidate the string pointer and take no action.
    ld     h,a
    ld     l,a
    ld     (vram_greenfont_charplace_string_ptr),hl
    ret
+:  ; We have read a nonzero character from the string.
    ; Increment the string pointer and store.
    inc    hl
    ld     (vram_greenfont_charplace_string_ptr),hl
    ; A holds the character read from the string.
    ; If it's a 1, it's a newline and we need to fiddle with the cursors.
    cp     1
    jp     nz,+
    ld     a,(vram_greenfont_charplace_tile_cursor_y)
    inc    a
    ld     (vram_greenfont_charplace_tile_cursor_y),a
    ld     a,(vram_greenfont_charplace_tile_cursor_x_start)
    ld     (vram_greenfont_charplace_tile_cursor_x),a
    ret
+:  ; It's a printable character! Print it!
    ld     hl,(greenfont_base_tile_number)
    ld     bc,'0'                                         ; Subtract '0' because that's the first printable character.
    and    a                                              ; Reset carry SAFELY.
    sbc    hl,bc
    ld     b,h
    ld     c,l                                            ; Move constructed base tile number into BC
    cp     ' '
    jp     nz,+                                           ; Non spaces are printed by subtracting the tile number of '0'
    ld     a,0                                            ; If it's a space, we want to use tile zero:
    jp     ++
+:
    add    a,c                                            ; Add on the base tile number (ignore that it's two byte. I can't be bothered with a sprite tile version now.)
++:
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    
    ; Advance the tile cursor.
    ld     a,(vram_greenfont_charplace_tile_cursor_x)
    inc    a
    ld     (vram_greenfont_charplace_tile_cursor_x),a

    ret

lose_vram_copy_static_tiles:
    ; I want to copy random static into tiles 1-16 in VRAM
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|32
    SetVDPAddress_de_UNSAFE
    ld     bc,8*16
    ld     hl,main                                      ; main is a good source of pretty randomness. Who knew?
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    xor    a                                            ; Load only first three bits. Bitplane 4 is all zeroes.
    out    (PORT_VDPData),a
    dec    bc
    ld     a,b
    or     c
    jp     nz,-

    ret

lose_vram_copy_contact_lost_tiles:
    ; Decompress the contact lost tiles from the huffman archive into RAM temporarily. (It's huffman encoded, and then crushed to 2bpp, so it needs to be expanded from RAM to VRAM!)
    ld     bc,ha1_graphics_contactlosttiles_2bpp_bin_fullsize
    ld     de,lose.graphics_contactlosttiles_2bpp_decompressed
    ld     hl,ha1_graphics_contactlosttiles_2bpp_bin_data
    call   ha1_decompress

    ; I want to copy the Contact Lost tiles into tiles 17-40 in VRAM
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|(32*17)
    SetVDPAddress_de_UNSAFE
    ld     b,8*22
    ld     hl,lose.graphics_contactlosttiles_2bpp_decompressed
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a                             ; Load first two bitplanes.
    ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    xor    a                                            ; Bitplane 3 is all zeroes.
    out    (PORT_VDPData),a
    ld     a,%11111111                                  ; Bitplane 4 is all ones. This means we're shifting a 2bpp input image into colours 8-12.
    out    (PORT_VDPData),a
    djnz   -

    ret

; These are the tile numbers to copy to display the CONTACT LOST text.
lose_vram_contact_lost_tile_mapping:
.db  17, 18, 17, 19, 17, 19, 20, 21, 17, 19, 17, 18, 20, 21, 22,  0, 17, 19, 17, 18, 20, 21
.db  23,  0, 23, 24, 23, 24, 25, 26, 27, 28, 23,  0, 25, 26, 23,  0, 23, 24, 29, 30, 25, 26
.db  31, 32, 31, 33, 34, 35, 36, 37, 34, 35, 31, 32, 36, 37, 31, 32, 31, 33, 38, 33, 36, 37

lose_vram_populate_nametable_with_contact_lost_tiles:
    ; I want to copy the Contact Lost nametable entries at position defined by LOSE_CONTACT_LOST_SECTION_Y_TOP
    ld     de,VDPCommand_VRAMWrite|VRAM_NametableRAM+((((LOSE_CONTACT_LOST_SECTION_Y_TOP/8) + 1)*2*32)+8)
    SetVDPAddress_de_UNSAFE
    ld     hl,lose_vram_contact_lost_tile_mapping
    ld     c,3
---:ld     b,22
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    xor    a
    out    (PORT_VDPData),a
    ld     a,b
    cp     9                                            ; When we reach the gap between the 'Contact' and the 'Lost'
    jp     nz,+
    xor    a
    out    (PORT_VDPData),a                             ; Insert a blank tile or two.
    nop
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
+:  djnz   -
    ld     b,14
-:  out    (PORT_VDPData),a
    djnz   -
    dec    c
    jp     nz,---

    ret


lose_vram_populate_nametable_with_static_tiles:
    ; Populate the entire nametable with random tiles in the range 1-16
    ld     de,VDPCommand_VRAMWrite|VRAM_NametableRAM
    SetVDPAddress_de_UNSAFE

    ld     hl,main
    ld     de,win_cinematic_0_frame
    ld     bc,32*28
-:  ld     a,(de)                                           ; Load from one random source
    add    a,(hl)                                           ; Add the other
    and    15
    inc    a                                                ; Range 1-16
    out    (PORT_VDPData),a
    inc    hl
    inc    de                                               ; Advance random counters
    dec    bc
    ld     a,b
    or     c                                                ; Set the loop termination flag.
    ld     a,0                                              ; Second byte is always zero
    out    (PORT_VDPData),a
    jp     nz,-

    ret

lose_fade_out_graphics_draw_explosion_bar:
    ; Depending on the value of anim_frame_counter, we need to draw
    ; a different explosion bar onto the screen.
    ; Thankfully, the master system's wrapping a lot easier to handle
    ; than the Amiga's.
    ; All we need to do is know which tile is roughly central on the screen and then
    ; mangle tiles above and below this.

    ; Draw a set number of rows depending on the animation frame
    ; At the end of this small section, A contains the row to start on
    ; and B contains the total number of rows.
    ld     a,(game.anim_frame_counter)
    cp     16                                            ; Take no action on frame >= 16
    ret    p

    ; draw the same number of rows as the frame counter? (32 frames long?)
;    ld     b,a                                           ; Draw the same number of rows as the frame counter.
;    ld     a,13
;    ld     c,b
;    srl    c
;    sub    c                                             ; Draw from the center of the screen outwards

    ; draw double the rows so it doesn't look all jangly? (16 frames long?)
    ld     c,a
    add    a,a
    ld     b,a                                           ; Draw double the frame counter.
    dec    b                                             ; minus one.
    ld     a,14
    sub    c                                             ; Draw from the center of the screen outwards

    ; Calculate what tile we're starting on.
    ; We're starting on the tile 13 below (on the screen) camera_y.
    ld     hl,(game.camera_y)
    srl    h                                             ; Convert camera coordinate to row number by dividing by 8.
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l                                             ; We have calculated the starting coordinate of a new row being drawn on the top...
    add    a,l                                           ; Add on the starting row we want.
-:  add    a,-28                                         ; Subtract 28 tentatively
    jp     p,-                                           ; Keep subtracting 28 until we go under
    add    a,28                                          ; A = y mod 28
    ; Now we have the number of the row we're drawing first.
    ld     c,a                                           ; Store the on-screen row number in C
    ld     h,0
    ld     l,a                                           ; HL' = 16 bit version of y mod 28
    add    hl,hl                                         ; HL' =  2*y
    add    hl,hl                                         ; HL' =  4*y
    add    hl,hl                                         ; HL' =  8*y
    add    hl,hl                                         ; HL' = 16*y
    add    hl,hl                                         ; HL' = 32*y
    add    hl,hl                                         ; HL' = 64*y
    ; x_contribution = zero, because we're drawing rows from the left of the nametable across.
    ld     de,VDPCommand_VRAMWrite|VRAM_NametableRAM
    add    hl,de                                         ; HL is now complete VDP Control command for directing writes into the nametable on the correct row on the left.
    SetVDPAddress_UNSAFE                                 ; Submit the VDP command. We only need to do this once as all the tiles are adjacent from now on.
    ld     a,28
    sub    c
    ld     c,a                                           ; C = 28 - the row number we start on. We draw this many rows until the modulo takes effect.
    ld     e,0                                           ; Use E as a counter to see if we're on the top row of tiles or not.

lose_fade_out_graphics_draw_explosion_bar_apply_row:
    ; Do this row of tiles.
    
    ; Calculate the tile number of the tile to draw in H
    ld     h,201                                         ; Draw tile 201 in the center
    dec    b                                             ; Decrement B temporarily to allow us to see if it's currently zero.
    jp     nz,+                                          ; If B == 0, we're on the bottom row
    inc    h
    inc    h                                             ; Draw tile 203 on the lower row.
+:  inc    b

    bit    0,e
    jp     nz,+                                          ; If E is nonzero, we're not on the top row.
    inc    h                                             ; Draw tile 202 on the top row.
    inc    e                                             ; Set the E flag to indicate we've already drawn the top row.
+:
    ld     d,32                                          ; D is the number of tiles in the row.

-:  ld     a,h                                           ; Retrieve tile number from H
    out    (PORT_VDPData),a                              ; Write the low byte of the data. (Tile number bits 7-0)
    xor    a
    push   ix                                            ; VDP timing DELAY!
    pop    ix
    out    (PORT_VDPData),a                              ; Write the high byte of the data. (---pcvhn)
    push   ix
    pop    ix
    dec    d
    jp     nz,-

    ; Advance to the next tile, apply the modulo.
    dec    c
    jp     nz,+                                          ; When we run out of rows to draw before the modulo:
    ld     c,99                                          ; Make this counter innocuous.
    ld     hl,VDPCommand_VRAMWrite|VRAM_NametableRAM     ; HL is now complete VDP Control command for directing writes into the nametable on the first row on the left.
    SetVDPAddress_UNSAFE                                 ; Submit the VDP command. We only need to do this once as all the tiles are adjacent from now on.
+:
    ; If we're on the ending tile, stop.
    djnz   lose_fade_out_graphics_draw_explosion_bar_apply_row
    ret

graphics_copy_faded_sprite_palette_to_white:
    ; Copy the sprite palettes from HL to CRAM, faded by a value based on E

    ; Construct the CRAM writing instruction:
    ld     bc,VDPCommand_CRAMWrite|$0010
    SetVDPAddress_bc_UNSAFE

    ; If we're being asked to add zero, copy the palette directly.
    bit    1,e
    jp     nz,+
    bit    0,e
    jp     nz,+
    ; We're being asked to add zero!
    ld     b,16
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    djnz   -
    ret
+:
    ; If we're being asked to add three, copy all white.
    bit    1,e
    jp     z,+
    bit    0,e
    jp     z,+
    ; We're being asked to add three!
    ld     b,16
    ld     a,%00111111
-:  out    (PORT_VDPData),a
    djnz   -
    ret
+:

    ; We're being asked to add %1 or %10 :(
    ld     b,16
-:  ; Construct the new colour in D.
    ; Load the old colour from (HL), and add E to all its channels.
    ld     c,(hl)
    inc    hl
    rlc    c                                            ; Rotate the colour so that the leftmost channel is in the bottom two bits
    rlc    c
    rlc    c
    rlc    c
    ld     a,c
    and    %00000011                                    ; Isolate the channel in the lowest two bits
    add    a,e
    cp     4
    jp     m,+
    ld     a,%00000011                                  ; If result overflows, clamp it to 3.
+:  ld     d,a                                          ; Put it into the lowest bits of D.

    rlc    c                                            ; Rotate the colour so that the middle channel is in the bottom two bits
    rlc    c
    ld     a,c
    and    %00000011                                    ; Isolate the channel in the lowest two bits
    add    a,e
    cp     4
    jp     m,+
    ld     a,%00000011                                  ; If result overflows, clamp it to 3.
+:  rlc    d
    rlc    d                                            ; Make a gap in D
    or     d
    ld     d,a                                          ; Put it into the lowest bits of D.

    rlc    c                                            ; Rotate the colour so that the rightmost channel is in the bottom two bits
    rlc    c
    ld     a,c
    and    %00000011                                    ; Isolate the channel in the lowest two bits
    add    a,e
    cp     4
    jp     m,+
    ld     a,%00000011                                  ; If result overflows, clamp it to 3.
+:  rlc    d
    rlc    d                                            ; Make a gap in D
    or     d                                            ; Construct final colour in A.

    out    (PORT_VDPData),a
    djnz   -

    ret


graphics_copy_faded_palettes_to_white:
    ; Call the below routine with preset parameters
    push   bc
    push   de

    ld     c,0
    ld     d,32
    call   graphics_copy_faded_palettes_to_white_limited

    pop    de
    pop    bc
    ret

graphics_copy_faded_palettes_to_white_limited:

    ; Copy the background and sprite palettes from HL to CRAM, faded by a value based on E
    ; Copy D colours, starting from the Cth.
    
    ; Construct the CRAM writing instruction:
    ld     a,c
    ld     bc,VDPCommand_CRAMWrite|$0000
-:  cp     0
    jp     z,+
    inc    bc                   ; Advance A colours.
    inc    hl
    dec    a
    jp     -
+:  SetVDPAddress_bc_UNSAFE

    ; This routine uses B as the loop counter.
    ld     b,d

    ; If we're being asked to add zero, copy the palette directly.
    bit    1,e
    jp     nz,+
    bit    0,e
    jp     nz,+
    ; We're being asked to add zero!
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    djnz   -
    ret
+:
    ; If we're being asked to add three, copy all white.
    bit    1,e
    jp     z,+
    bit    0,e
    jp     z,+
    ; We're being asked to add three!
    ld     a,%00111111
-:  out    (PORT_VDPData),a
    djnz   -
    ret
+:

    ; We're being asked to add %1 or %10 :(
-:  ; Construct the new colour in D.
    ; Load the old colour from (HL), and add E to all its channels.
    ld     c,(hl)
    inc    hl
    rlc    c                                            ; Rotate the colour so that the leftmost channel is in the bottom two bits
    rlc    c
    rlc    c
    rlc    c
    ld     a,c
    and    %00000011                                    ; Isolate the channel in the lowest two bits
    add    a,e
    cp     4
    jp     m,+
    ld     a,%00000011                                  ; If result overflows, clamp it to 3.
+:  ld     d,a                                          ; Put it into the lowest bits of D.

    rlc    c                                            ; Rotate the colour so that the middle channel is in the bottom two bits
    rlc    c
    ld     a,c
    and    %00000011                                    ; Isolate the channel in the lowest two bits
    add    a,e
    cp     4
    jp     m,+
    ld     a,%00000011                                  ; If result overflows, clamp it to 3.
+:  rlc    d
    rlc    d                                            ; Make a gap in D
    or     d
    ld     d,a                                          ; Put it into the lowest bits of D.

    rlc    c                                            ; Rotate the colour so that the rightmost channel is in the bottom two bits
    rlc    c
    ld     a,c
    and    %00000011                                    ; Isolate the channel in the lowest two bits
    add    a,e
    cp     4
    jp     m,+
    ld     a,%00000011                                  ; If result overflows, clamp it to 3.
+:  rlc    d
    rlc    d                                            ; Make a gap in D
    or     d                                            ; Construct final colour in A.

    out    (PORT_VDPData),a
    djnz   -

    ret


graphics_copy_faded_palettes_to_black:
    ; Call the below routine with preset parameters
    push   bc
    push   de

    ld     c,0
    ld     d,32
    call   graphics_copy_faded_palettes_to_black_limited

    pop    de
    pop    bc
    ret

graphics_copy_faded_palettes_to_black_limited:

    ; Copy the background and sprite palettes from HL to CRAM, faded by a value based on E
    ; Copy D colours, starting from the Cth.

    ; Construct the CRAM writing instruction:
    ld     a,c
    ld     bc,VDPCommand_CRAMWrite|$0000
-:  cp     0
    jp     z,+
    inc    bc                   ; Advance A colours.
    inc    hl
    dec    a
    jp     -
+:  SetVDPAddress_bc_UNSAFE

    ; This routine uses B as the loop counter.
    ld     b,d

    ; If we're being asked to subtract zero, copy the palette directly.
    bit    1,e
    jp     nz,+
    bit    0,e
    jp     nz,+
    ; We're being asked to subtract zero!
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    djnz   -
    ret
+:
    ; If we're being asked to subtract three, copy all black.
    bit    1,e
    jp     z,+
    bit    0,e
    jp     z,+
    ; We're being asked to subtract three!
    xor    a
-:  out    (PORT_VDPData),a
    djnz   -
    ret
+:

    ; We're being asked to subtract %1 or %10 :(
-:  ; Construct the new colour in D.
    ; Load the old colour from (HL), and subtract E to all its channels.
    ld     c,(hl)
    inc    hl
    rlc    c                                            ; Rotate the colour so that the leftmost channel is in the bottom two bits
    rlc    c
    rlc    c
    rlc    c
    ld     a,c
    and    %00000011                                    ; Isolate the channel in the lowest two bits
    sub    e
    jp     p,+
    xor    a                                            ; If result underflows, clamp it to 0.
+:  ld     d,a                                          ; Put it into the lowest bits of D.

    rlc    c                                            ; Rotate the colour so that the middle channel is in the bottom two bits
    rlc    c
    ld     a,c
    and    %00000011                                    ; Isolate the channel in the lowest two bits
    sub    e
    jp     p,+
    xor    a                                            ; If result underflows, clamp it to 0.
+:  rlc    d
    rlc    d                                            ; Make a gap in D
    or     d
    ld     d,a                                          ; Put it into the lowest bits of D.

    rlc    c                                            ; Rotate the colour so that the rightmost channel is in the bottom two bits
    rlc    c
    ld     a,c
    and    %00000011                                    ; Isolate the channel in the lowest two bits
    sub    e
    jp     p,+
    xor    a                                            ; If result underflows, clamp it to 0.
+:  rlc    d
    rlc    d                                            ; Make a gap in D
    or     d                                            ; Construct final colour in A.

    out    (PORT_VDPData),a
    djnz   -

    ret

; This is the ISR we use when we're expecting VBlanks only.
; On VBlank, increment the value var_VBlankTokenReady
isr_vblank_only:
    push   af
    in     a,(PORT_VDPStatus)               ; Read VDP status to acknowledge interrupt. (Otherwise the VDP will just keep sending 'em!)
isr_vblank_acknowledgement:
    ld     a,(var_VBlankTokenReady)         ; If we wanted to use this as a flag instead of a 'reverse semaphore', we could use 'xor a' instead here to reset a to 0.
    inc    a
    ld     (var_VBlankTokenReady),a      
    pop    af
    ret

isr_vblank_acknowledgement_af_prime:
    ld     a,(var_VBlankTokenReady)         ; If we wanted to use this as a flag instead of a 'reverse semaphore', we could use 'xor a' instead here to reset a to 0.
    inc    a
    ld     (var_VBlankTokenReady),a
    ex     af,af'                           ; If the isr that redirected to here preserved af with af', we need to respect that!
    ret

isr_lose_contact_lost:
    push   af
    in     a,(PORT_VDPStatus)                          ; Read VDP status to acknowledge interrupt.
    and    VDP_Status_VBlank_bit
    jp     nz,isr_vblank_acknowledgement               ; If the bit is set, it's a vblank. Jump into the middle of its normal acknowledgement routine.
    ; HBlanks only past this point, boss!
isr_lose_contact_lost_hblank_section:
    ; What position are we in?
    in     a,(PORT_VDPVCount)
    cp     LOSE_CONTACT_LOST_SECTION_Y_TOP
    jp     nz,+
    ; If we're in section 0, we want to set X scrolling to zero, and set up the next interrupt
    xor    a
    out    (PORT_VDPControl),a                         ; We already have zero in A at this point. BONUS.
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
    pop    af
    ret
+:
    cp     LOSE_CONTACT_LOST_SECTION_Y_TOP+LOSE_CONTACT_LOST_SECTION_Y_SIZE-1
    jp     nz,+
    ld     a,(lose.scroll_register_x)
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
+:  pop    af
    ret

isr_win_cinematic_0:
    ex     af,af'                                      ; Use shadow registers because we KNOW the cinematic doesn't use them. (But what about the audio and every other freakin' library, lol?)
    in     a,(PORT_VDPStatus)                          ; Read VDP status to acknowledge interrupt.
    and    VDP_Status_VBlank_bit
    jp     nz,isr_vblank_acknowledgement_af_prime      ; If the bit is set, it's a vblank. Jump into the middle of its normal acknowledgement routine.
    ; HBlanks only past this point, boss!
isr_win_cinematic_0_hblank_section:

    ; Now then now then now then.
    ; If I simply alter the sprite AT address at this time instantly, I get a blank line in the
    ; big ship.
    ; I suspect that it's due to a caching effect as demonstrated by Charles MacDonald in
    ; this http://www.smspower.org/forums/viewtopic.php?t=6614
    ; BUT (and people who know how the SMS works are probably going to have their eyes melt after reading this)
    ; *IF* the 'caching something' occurs as the 'beam' is coming from the left of the screen
    ; (i.e. the cache happens at the start of the line contemporaneously as the interrupt is fired)
    ; would it be possible for me to time this AT change so that it occurs somewhere BEFORE this?
    ; To do this, I change the AT way waaaaay in the future of the current line, about two thirds of the
    ; way across the screen.
    ; With This Magic Power, I will have the 'beam' draw the big ship using the old AT address, then,
    ; while I know nothing is on the right side of the screen, trigger the change.
    ; The expected result is that the sprite system of the VDP barfs for a while, sorts itself out,
    ; the next line occurs, the caching effect takes place with the new sprite AT address,
    ; and the big ship is displayed with no horrible blank line in the big ship.
    ; SO I THINK ALL I NEED IS THE AT SWITCH TO OCCUR WHILE THE BEAM IS SPRITELY IDLE.

    ; Draw the greenwing to the screen AGAIN, 64 pixels below its current position, using the lower half of the big sprite.
    ; Write to the sprite table base address VDP register and set the sprite AT address to $3F00
    ld     a,%01111110
    out    (PORT_VDPControl),a
    nop
    nop
    push   ix             ; By sheer fluke, this arrangement of pushes and pops of
    pop    ix             ; IX delays the writing of the final part of the VDP command
    push   ix             ; to a point where the composition beam is to the right of the
    pop    ix             ; big ship on screen. The result is that the sprite table selection
    push   ix             ; transition will occur while the beam is idle, the two halves of
    pop    ix             ; the ship will come together with no seam and everybody is happy! 2013/03/22 matt carr.
                          ; Tested on a PAL Master System II

    ld     a,VDP_Register_SpriteATBase|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

isr_win_cinematic_0_hblank_section_no_effect_restore_af:
    ex     af,af'
    ret

isr_plot_1_alert_bar_scroll:
    push   af
    in     a,(PORT_VDPStatus)                          ; Read VDP status to acknowledge interrupt.
    and    VDP_Status_VBlank_bit
    jp     nz,isr_vblank_acknowledgement               ; If the bit is set, it's a vblank. Jump into the middle of its normal acknowledgement routine.
    ; HBlanks only past this point, boss!
isr_plot_1_alert_bar_scroll_hblank_section:
    ; What position are we in?
    in     a,(PORT_VDPVCount)
    cp     PLOT_1_ALERT_SCROLL_SECTION_Y_TOP
    jp     nz,+
    ; If we're in section 0, we want to set X scrolling to zero, and set up the next interrupt
    ld     a,(plot_1.alert_scroll_register_x)
    out    (PORT_VDPControl),a                         ; We already have zero in A at this point. BONUS.
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
    pop    af
    ret
+:
    cp     PLOT_1_ALERT_SCROLL_SECTION_Y_TOP+PLOT_1_ALERT_SCROLL_SECTION_Y_SIZE-1
    jp     nz,+
    xor    a
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
+:  pop    af
    ret


; Sets the VDP address
; From Maxim's World of Stuff
; Parameters: hl = address
SetVDPAddress:
    push   af
    ld     a,l
    out    (PORT_VDPControl),a
    ld     a,h
    out    (PORT_VDPControl),a
    pop    af
    ret

; Initialise the game state in RAM to the start of a new level.
game_state_init:
    ld     hl,0
    xor    a
    
    ld     (game.game_paused),a

    ld     (game.camera_old_x),hl
    ld     (game.camera_old_y),hl

    ld     (game.camera_x),hl
    ld     (game.camera_y),hl

    ld     (game.camera_focus_x),hl
    ld     (game.camera_focus_y),hl

    ld     (game.tiles_row_y),a
    ld     (game.tiles_column_x),a

    ld     (game.player_orientation),a
    ld     (game.player_sprite_frame),a

    ld     (game.player_position_x),hl
    ld     (game.player_position_y),hl
    ld     (game.player_position_x_pixels),hl
    ld     (game.player_position_y_pixels),hl
    ld     (game.player_velocity_x),hl
    ld     (game.player_velocity_y),hl

    ld     (game.box_position_x),hl
    ld     (game.box_position_y),hl
    ld     (game.box_position_x_pixels),hl
    ld     (game.box_position_y_pixels),hl
    ld     (game.box_velocity_x),hl
    ld     (game.box_velocity_y),hl

    ld     (game.player_link_established),a
    ld     (game.ingame_carrybox_flash_frame),a

    ld     (game.anim_frame_counter),a

    ld     (game.scroll_register_y),a
    ld     a,8
    ld     (game.scroll_register_x),a

    ld     hl,296*16
    ld     (game.player_position_x),hl
    ld     hl,159*16
    ld     (game.player_position_y),hl
    ld     hl,841*16
    ld     (game.box_position_x),hl
    ld     hl,666*16
    ld     (game.box_position_y),hl

.endasm
    ld     hl,296*16
    ld     (game.box_position_x),hl
    ld     hl,100*16
    ld     (game.box_position_y),hl
.asm

    ld     hl,CARRYBOX_INITIAL_HEALTH
    ld     (game.ingame_carrybox_remaining_health),hl

    ; The timer starts at 5:00:00.
    xor    a
    ld     (game_persistent.ingame_bombled_seconds_counter_h),a
    ld     (game_persistent.ingame_bombled_seconds_counter_l),a
    ld     (game_persistent.ingame_bombled_hundredths_counter_h),a
    ld     (game_persistent.ingame_bombled_hundredths_counter_l),a
    ld     a,5
    ld     (game_persistent.ingame_bombled_minutes_counter),a

.endasm  what, you WANT the world to explode or something? You really are a maniac!
    ld     a,0
    ld     (game_persistent.ingame_bombled_minutes_counter),a
    ld     a,1
    ld     (game_persistent.ingame_bombled_seconds_counter_h),a
    ld     a,0
    ld     (game_persistent.ingame_bombled_seconds_counter_l),a
    ld     a,0
    ld     (game_persistent.ingame_bombled_hundredths_counter_h),a
    ld     a,2
    ld     (game_persistent.ingame_bombled_hundredths_counter_l),a
.asm
  
    ; Configurable controls.
    ld     a,1<<CONTROLLER_BIT_BUTTON_1
    ld     (game_persistent.beam_button_mask),a
    ld     a,1<<CONTROLLER_BIT_BUTTON_2
    ld     (game_persistent.thrust_button_mask),a
    ld     a,(game_persistent.controls_inverted)
    cp     0
    jp     z,+
    ld     a,1<<CONTROLLER_BIT_BUTTON_2
    ld     (game_persistent.beam_button_mask),a
    ld     a,1<<CONTROLLER_BIT_BUTTON_1
    ld     (game_persistent.thrust_button_mask),a                                      
+:


    ret

game_vram_init:
    ; I should blank the VRAM here. If there's garbage in the lower
    ; part of the tiles I use for the greenwing, it'll stay there!!
    call   vram_clear_all

    ; Copy the carrybox to VRAM tiles (256+) 4 and 5, followed by the two rows of the linkage graphic into tile 6.
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|$2000+(32*4)
    SetVDPAddress_de_UNSAFE
    ld     hl,graphics_carrybox
    ld     b,64+8
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPData),a
    djnz   -

    ; Copy the bombleds to VRAM tiles (256+) 7-20
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|$2000+(32*7)
    SetVDPAddress_de_UNSAFE
    ld     bc,ha1_graphics_bombleds_bin_fullsize
    ld     de,0
    ld     hl,ha1_graphics_bombleds_bin_data
    call   ha1_decompress

    ; Copy the gaiden tiles to the pattern data VRAM tiles 0-200odd
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM
    SetVDPAddress_de_UNSAFE
    ld     bc,ha1_graphics_gaiden_ingame_tiles_bin_fullsize
    ld     de,0
    ld     hl,ha1_graphics_gaiden_ingame_tiles_bin_data
    call   ha1_decompress
    ; These also contain the three final tiles used for the explosion bar
    ; when you lose.

    ; Decompress the greenwing tiles into RAM from the archive.
    ld     bc,ha1_graphics_greenwing_bin_fullsize
    ld     de,game.greenwing_sprite_decompressed_ram
    ld     hl,ha1_graphics_greenwing_bin_data
    call   ha1_decompress

    ; Decompress the megatiles array into RAM from the archive.
    ld     bc,ha1_levellayout_megatiles_bin_fullsize
    ld     de,game.megatiles_array_decompressed
    ld     hl,ha1_levellayout_megatiles_bin_data
    call   ha1_decompress

    ; Copy the large font into the sprite tiles, this allows us to show the countin numbers.
    call   game_vram_load_count_in_tiles

    ret

game_vram_load_count_in_tiles:
    ; Use an alternate colour decoding to allow us to have the font
    ; coexist with some other graphic. (Used ingame for the countin numbers.)      

    ld     hl,VDPCommand_VRAMWrite|VRAM_PatternRAM|(32*(256+21))
    SetVDPAddress_UNSAFE
    ld     hl,graphics_count_in_digits_2bpp
    ld     bc,(graphics_count_in_digits_2bpp_end-graphics_count_in_digits_2bpp)/2
-:  ld     e,(hl)                                        ; Load the two source pixel rows into de. E contains least significant bit pixel (DE = ML)
    inc    hl
    ld     d,(hl)
    inc    hl
    ; I've encoded the greenfont as a 2bpp planar tile thing. I'm going to expand that into a 4bpp palette using bitwise operations
    ; Source             Destination
    ; 0       00          0 0000
    ; 1       01   --->   9 1001
    ; 2       10          A 1010
    ; 3       11          B 1011

    ; Least significant output bit = L
    ld     a,e
    out    (PORT_VDPData),a
    ; Second output bit = M
    ld     a,d
    out    (PORT_VDPData),a
    ; Third output bit = 0
    xor    a
    out    (PORT_VDPData),a
    ; Fourth output bit = M or L
    ld     a,e
    or     d
    out    (PORT_VDPData),a
    dec    bc
    ld     a,b
    or     c
    jp     nz,-
    ret

ingame_set_scroll_registers:
    ld     a,(game.scroll_register_x)
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollX|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
    ld     a,(game.scroll_register_y)
    out    (PORT_VDPControl),a
    ld     a,VDP_Register_ScrollY|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a

    ret

; Add the value in B to scroll_y, ensuring that scroll_y is always in the range $00-$DF
; Invalidates A.
scroll_y_add_b:
    ld     a,(game.scroll_register_y)
    add    a,b
    jp     nc,+
    ; If carry: (it went over $FF) add the missing $20 and store.
    add    a,$20
    ld     (game.scroll_register_y),a
    ret
+:  cp     $E0
    jp     c,+
    ; If a+b > $E0, subtract $E0 and store.
    and    $1F
+:  ld     (game.scroll_register_y),a ; store all other values finally.
    ret

; Subtract the value in B to scroll_y, ensuring that scroll_y is always in the range $00-$DF
; Invalidates A.
scroll_y_sub_b:
    ld     a,(game.scroll_register_y)
    sub    b
    jp     nc,+   ; If no underflow: store, done.
    ; If it underflowed, subtract the $20 again
    sub    $20
+:  ld     (game.scroll_register_y),a
    ret

; Update the scroll registers based on the camera routine:
ingame_camera_logic_displace_scroll_registers:
    ; Okay, the camera has moved a bit, PERHAPS. We subtract the old camera position from the new one to get the displacement
    ; and then use the add functions to make sure the scroll registers are valid. (The scroll register X

    ; X is quite direct (the X size of the SMS tilemap facility is 256, so no fancy maths are needed)
    ld     hl,(game.camera_x)
    ld     de,(game.camera_old_x)
    and    0
    sbc    hl,de
    ld     a,(game.scroll_register_x)
    sub    l
    ld     (game.scroll_register_x),a

    ; Y is more complicated as it has a modulo 224, as this is the size of the SMS tilemap facility.
    ld     hl,(game.camera_y)
    ld     de,(game.camera_old_y)
    and    0
    sbc    hl,de
    jp     m,+                        ; Call either the scroll add or subtract subroutines depending on result of calculation.
    ld     b,l
    jp     scroll_y_add_b
+:  ld     a,l                        ; A = L, l is negative
    neg                               ; A = -L, which is positive
    ld     b,a                        ; B = -L
    jp     scroll_y_sub_b
; END ingame_camera_logic_displace_scroll_registers

; NB. This routine messes with camera_x and camera_y.
; If I'm going to clamp the cameras scroll speed, then
; it's important to change this routine to mess with camera_focus_x
; and camera_focus_y instead. Then, I'll need to write another routine
; that does something like:
;  if camera_x != camera_focus_x
;    if camera_x < camera_focus_x, camera_x += max( 5, camera_focus_x-camera_x) ret
;    if camera_x > camera_focus_x, camera_x += min(-5, camera_focus_x-camera_x) ret
; this function would clamp the scroll speed to a specified value, which means that
; the tile placement routine does not need to be called more than once per axis!

; Attempt to move the camera to focus the screen on the player
ingame_camera_logic_safely_track_player:
    ; Calculate the X position that the camera would try to use:
    ld     hl,(game.player_position_x_pixels)
    ld     de,VISIBLE_DISPLAY_X_SIZE/2                  ; Subtract half the size of the screen.
    xor    a                                            ; Clear carry
    sbc    hl,de
    ; The camera X wants to go here... but is it valid?
    jp     nc,+
    ; It's invalid if it's negative, so set it to zero.
    ld     hl,0
    ld     (game.camera_x),hl
    jp     ingame_camera_logic_safely_track_player_y
    ; Check to see if it's beyond the maximum value. The maximum value is 312*3
+:  ld     d,h
    ld     e,l                                          ; Copy desired camera value into DE
    ld     bc,GAME_WORLD_X_SIZE-VISIBLE_DISPLAY_X_SIZE
    xor    a                                            ; Clear carry
    sbc    hl,bc                                        ; if HL > BC, the result will be positive
    ex     de,hl                                        ; Get the desired camera value back in HL
    jp     m,+
    ; If the result is positive, HL is too big. Clamp it.
    ld     hl,GAME_WORLD_X_SIZE-VISIBLE_DISPLAY_X_SIZE
+:  ld     (game.camera_x),hl
    jp     ingame_camera_logic_safely_track_player_y

ingame_camera_logic_safely_track_player_y:
    ; Calculate the Y position that the camera would try to use:
    ld     hl,(game.player_position_y_pixels)
    ld     de,VISIBLE_DISPLAY_Y_SIZE/2                  ; Subtract half the size of the screen.
    xor    a                                            ; Clear carry
    sbc    hl,de
    ; The camera Y wants to go here... but is it valid?
    jp     nc,+
    ; It's invalid if it's negative, so set it to zero.
    ld     hl,0
    ld     (game.camera_y),hl
    ret
    ; Check to see if it's beyond the maximum value. The maximum value is 192*3
+:  ld     d,h
    ld     e,l                                          ; Copy desired camera value into DE
    ld     bc,GAME_WORLD_Y_SIZE-VISIBLE_DISPLAY_Y_SIZE
    xor    a                                            ; Clear carry
    sbc    hl,bc                                        ; if HL > BC, the result will be positive
    ex     de,hl                                        ; Get the desired camera value back in HL
    jp     m,+
    ; If the result is positive, HL is too big. Clamp it.
    ld     hl,GAME_WORLD_Y_SIZE-VISIBLE_DISPLAY_Y_SIZE
+:  ld     (game.camera_y),hl

    ret

; There's a velocity value below which we will subtract constant 1
; rather than attempt to use shifted values, because they'll have disintegrated
; into zeroes below this value.
.define INGAME_VELOCITY_DECAY_WONKY_THRESHOLD 100

; Decay the velocity value HL by the decay algorithm. Output in HL.
; It has different execution routes for:
;           value < -thresh         -thresh < value < 0       0          0 < value < thresh             thresh < value
;   negative shift-based  ---|  negative constant-based ---- |0| ---- positive constant-based  |---  positive shift-based
; This function is a PITA, tbh.
ingame_object_velocity_decay:
    ld     a,h
    or     l
    ret    z                                          ; Abort if velocity == 0

    ld     d,h
    ld     e,l
    bit    7,h                                        ; Check if we have positive or negative velocity:
    jp     nz,++                                      ; Negative velocities are a pain in the behind! Let's GO!
    ld     bc,-INGAME_VELOCITY_DECAY_WONKY_THRESHOLD
    xor    a                                          ; Reset carry.
    adc    hl,bc                                      ; Perform 16-bit subtraction to test magnitude of positive velocity
    jp     p,+                                        ; if (HL - thresh) is positive, lets do a shift-like velocity decay.
    ; HL is less than 256, so lets do a wonky constant decay thing.
    ex     de,hl
    ld     bc,-1
    add    hl,bc
    ret
+:  ; HL is more than 256, so lets use a shift to make a nice slidey halt.
    ld     h,d
    ld     l,e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    xor    a
    sbc    hl,de
    ret
++: ; We're trying to decay a negative velocity. Jeez.
    ld     bc,INGAME_VELOCITY_DECAY_WONKY_THRESHOLD
    xor    a                                          ; Reset carry.
    adc    hl,bc                                      ; Perform 16-bit addition to test magnitude of negative velocity
    jp     m,+                                        ; if (HL + thresh) is negative, lets do a shift-like velocity decay.
    ; HL is 'less' magnitudey than -256, so lets do a wonky constant decay thing.
    ex     de,hl
    ld     bc,1
    add    hl,bc
    ret
+:  ; HL is 'more' magnitudey than -256, so lets use a shift to make a nice slidey halt.
    ld     h,d
    ld     l,e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    xor    a
    sbc    hl,de
    ret

; Update the cached version of the player's position in pixels.
; *Call this every time we change the player's position*
; We only use the fixed point version when we're doing tricky
; mathematical elastic simulation stuff.
; For simple collision or camera control, we use the cached pixel
; version instead.
ingame_update_player_and_box_position_pixels_from_fixed_point:
    ld     hl,(game.player_position_x)
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    ld     (game.player_position_x_pixels),hl

    ld     hl,(game.player_position_y)
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    ld     (game.player_position_y_pixels),hl

    ld     hl,(game.box_position_x)
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    ld     (game.box_position_x_pixels),hl

    ld     hl,(game.box_position_y)
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    ld     (game.box_position_y_pixels),hl
    ret
    
ingame_bombled_decrement_timer:
    ; I can either do this with loads of explicit memory locations,
    ; Or I can do it with HL. The HL version is a lot small in
    ; size and runs a bit faster though.

    ;         minutes
    ;         | seconds high
    ;         | |seconds low
    ;         | || hundredths high
    ;         | || |hundredths low
    ; Timer = M SS ms.
    ; The minutes is in the smallest memory location, ascending to the hundredths low.
    ; Which means that to go from lowest significance to highest significance, we need
    ; to DEC backwards through the memory.

    ; UNLIKE DEUS EX: HUMAN REVOLUTION, this timer's hundredths counter works properly!

    ; To advance the counter, we take 2 hundredths from the hundredths low.
    ; When we run out of hundredths low, we take one from hundredths high.
    ; And so on, propagating up the timer whenever a carry is required.

    ld     hl,game_persistent.ingame_bombled_hundredths_counter_l
    ld     a,(hl)
    dec    a
    dec    a ; PAL PAL PAL!!! 50 frames per seconds in PAL!
    jp     m,+
    ld     (hl),a
    ret
+:  ld     a,8
    ld     (hl),a
    dec    hl                                ; HL now points to hundredths high.
    ld     a,(hl)
    dec    a
    jp     m,+
    ld     (hl),a
    ret
+:  ld     a,9
    ld     (hl),a
    dec    hl                                ; HL now points to seconds low.
    ld     a,(hl)
    dec    a
    jp     m,+
    ld     (hl),a
    ret
+:  ld     a,9
    ld     (hl),a
    dec    hl                                ; HL now points to seconds high.
    ld     a,(hl)
    dec    a
    jp     m,+
    ld     (hl),a
    ret
+:  ld     a,5
    ld     (hl),a
    dec    hl                                ; HL now points to minutes high.
    ld     a,(hl)
    dec    a
    ld     (hl),a
    ret

; Draw the tiles that fill the screen for the player's initial placement:
ingame_graphics_draw_initial_screen_tiles:

    ; After messing around with tricky fractional maths, update
    ; the pixel cached versions to allow the camera and sprite stuff
    ; to work.
    call   ingame_update_player_and_box_position_pixels_from_fixed_point

    ; Attempt to move the camera to focus the screen on the player
    call   ingame_camera_logic_safely_track_player
    ; Update the scroll registers based on the camera's motion.
    call   ingame_camera_logic_displace_scroll_registers

    ld     a,(game.camera_x+1)                        ; Load the high byte of the camera_x coordinate into a.
    rrca
    rrca
    rrca                                              ; Shift the camera_x to the right three times to divide by 8
                                                      ; We now have the camera_x in tiles, rounded down to the nearest multiple of 32.
    add    a,32                                       ; Advance to the next screen. We should start the tile drawing at this x index!
    ld     b,a
    ld     a,(game.camera_x)                          ; Load the low byte of the camera_x coordinate into a.
    and    %11111000
    rrca
    rrca
    rrca                                              ; Divide by eight to get the camera_x in tiles
    ; We now have the number of tiles within the current screen in a.
    ; This is the countdown timer we want to use in C for ingame_tiles_draw_row
    ld     c,a

    ; Calculate the row of 8x8 tiles that appears at the top of the screen:
    ld     hl,(game.camera_y)
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    ld     a,l
    
    ; Loop counter for drawing rows.
    ld     hl,25

-:  push   af
    push   bc
    push   hl
    call   ingame_tiles_draw_row
    pop    hl
    pop    bc
    dec    hl
    ld     a,l
    or     h
    jp     z,+
    pop    af
    inc    a
    jp     -
+:
    pop    af

    ret

; Analyse the new camera_x/y position and see if we need to draw new tiles on
; the incoming edge of a moving screen.
ingame_graphics_draw_new_rows_columns:
    call   ingame_graphics_draw_new_columns
    call   ingame_graphics_draw_new_rows
    ret

ingame_graphics_draw_new_rows:
    ; Check to see if we need to draw a new row based on the camera's change in position.
    ld     a,(game.camera_y)
    and    %11111000
    ld     e,a
    ld     a,(game.camera_y+1)
    ld     d,a                                                              ; DE = camera_y & not 7
    ld     hl,(game.camera_old_y)
    ld     a,l
    and    %11111000
    ld     l,a                                                              ; HL = camera_old_y & not 7
    sbc    hl,de                                                            ; hl = camera_y & not 7 - camera_old_y & not 7
    ; A contains the number of rows we need to draw. Negative for rows on the bottom, position for rows on the top
    ; The new row number is (camera_y>>3)+24 for bottomside rows, and (camera_y>>3) for topside rows.
    ; ASSUME WE'RE DRAWING A SINGLE ROW AT A TIME. We should clamp the camera's slide speed to 8 pixels/frame to prevent any cock-ups!!!
    jp     z,ingame_camera_draw_no_new_rows

    ; We know we want to draw some rows. We now calculate the B and C parameters which are the same
    ; regardless of whether the new row appears on the top or bottom of the visible screen.
    ; B = starting x coordinate that appears on the left side of the nametable as we scan across it. this is a multiple of the nametable width.
    ; C = number of tiles along before the discontinuity appears and we 'go off' the right of the screen and 'reappear on the left'.
    push   af                                         ; Push the flags so we can do the following calculations without destroying the universe
       ld     a,(game.camera_x+1)                        ; Load the high byte of the camera_x coordinate into a.
       rrca
       rrca
       rrca                                              ; Shift the camera_x to the right three times to divide by 8
                                                         ; We now have the camera_x in tiles, rounded down to the nearest multiple of 32.
       add    a,32                                       ; Advance to the next screen. We should start the tile drawing at this x index!
       ld     b,a
       ld     a,(game.camera_x)                          ; Load the low byte of the camera_x coordinate into a.
       and    %11111000
       rrca
       rrca
       rrca                                              ; Divide by eight to get the camera_x in tiles
       ; We now have the number of tiles within the current screen in a.
       ; This is the countdown timer we want to use in C for ingame_tiles_draw_row
       ld     c,a
    pop    af ; By popping the flags, we can retain the result whether the camera coordinate subtraction was positive or negative.

    jp     p,ingame_camera_draw_new_rows_on_top
    ld     hl,(game.camera_y)
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    ld     a,l
    add    a,24                                       ; We have calculated the starting coordinate of a new row being drawn on the bottom.
    call   ingame_tiles_draw_row
    jp     ingame_camera_draw_rows_complete
ingame_camera_draw_new_rows_on_top:
    ld     hl,(game.camera_y)
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    ld     a,l                                         ; We have calculated the starting coordinate of a new row being drawn on the top.
    call   ingame_tiles_draw_row
ingame_camera_draw_rows_complete:
ingame_camera_draw_no_new_rows:
    ret

ingame_graphics_draw_new_columns:
    ; Check to see if we need to draw a new column based on the camera's change in position.
    ld     a,(game.camera_x)
    and    %11111000
    ld     e,a
    ld     a,(game.camera_x+1)
    ld     d,a                                                              ; DE = camera_x & not 7
    ld     hl,(game.camera_old_x)
    ld     a,l
    and    %11111000
    ld     l,a                                                              ; HL = camera_old_x & not 7
    sbc    hl,de                                                            ; hl = camera_x & not 7 - camera_old_x & not 7
    ; HL contains the number of columns we need to draw. Negative for columns on the right, position for columns on the left
    ; The new column number is (camera_x>>3)+31 for right hand columns, and (camera_x>>3) for left hand columns.
    ; ASSUME WE'RE DRAWING A SINGLE COLUMN AT A TIME. We should clamp the camera's slide speed to 8 pixels/frame to prevent any cock-ups!!!
    jp     z,ingame_camera_draw_no_new_columns
    
    ; We know we want to draw some rows. We now calculate the B and C parameters which are the same
    ; regardless of whether the new row appears on the top or bottom of the visible screen.
    ; B = starting y coordinate that appears on the top side of the nametable as we scan across it. this is a multiple of the nametable height.
    ;   B = (camera_y rounded down to lowest multiple of 28) + 28
    ; C = number of tiles down before the discontinuity appears and we 'go off' the bottom of the screen and 'reappear on the top'.
    ;   C = camera_y mod 28
    push   af                                         ; Push the flags so we can do the following calculations without destroying the universe
       ld     hl,(game.camera_y)                         ; Load camera_y into hl
       srl    h
       rr     l
       srl    h
       rr     l
       srl    h
       rr     l                                          ; Get camera_y in tiles.
       ld     d,h
       ld     e,l                                        ; Copy HL into DE
       ld     bc,-28
-:     xor    a                                          ; Reset carry.
       adc    hl,bc                                      ; Subtract 28 from HL.
       jp     p,-                                        ; Repeatedly subtract 28 until HL is negative
       ld     bc,28
       add    hl,bc                                      ; HL is now camera_y mod 28
       ex     de,hl                                      ; Get camera_y in tiles back again in HL. DE contains modulo value
       xor    a                                          ; Reset carry again.
       sbc    hl,de                                      ; Subtract modulo value from HL to get good B parameter in L
       add    hl,bc                                      ; Add on the 28 that goes on top of the modulo
       ld     b,l                                        ; The starting y value is read from L
       ld     c,e                                        ; The modulo value is still stored in E
    pop    af ; By popping the flags, we can retain the result whether the camera coordinate subtraction was positive or negative.

    jp     p,ingame_camera_draw_new_columns_on_left
    ld     hl,(game.camera_x)
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    ld     a,l
    add    a,31                                        ; We have calculated the starting coordinate of a new row being drawn on the right.
    call   ingame_tiles_draw_column
    jp     ingame_camera_draw_columns_complete
ingame_camera_draw_new_columns_on_left:
    ld     hl,(game.camera_x)
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    ld     a,l                                         ; We have calculated the starting coordinate of a new row being drawn on the left.
    call   ingame_tiles_draw_column
ingame_camera_draw_columns_complete:
ingame_camera_draw_no_new_columns:

    ret


; We need a subroutine to draw a vertical column of game tiles to the nametable.
; We want to draw column (in 8x8 tiles) x=a, starting at y=b (must be a multiple of 28), drawing c tiles until looping.
ingame_tiles_draw_column:
    ; Calculate offset into megatiles array

    ; There are 64 megatiles across the GBMGX screen.
    ; We need to halve the Y coordinate first as we're thinking of megatiles.
    ld     h,0
    ld     l,b
    srl    l                                             ; HL = (Y/2)
    ; Multiply the Y/2 coordinate by 64 dec:
    add    hl,hl                                         ; HL = (Y/2)*2
    add    hl,hl                                         ; HL = (Y/2)*4
    add    hl,hl                                         ; HL = (Y/2)*8
    add    hl,hl                                         ; HL = (Y/2)*16
    add    hl,hl                                         ; HL = (Y/2)*32
    add    hl,hl                                         ; HL = (Y/2)*64
    ld     de,game.megatiles_array_decompressed
    add    hl,de                                         ; HL = &game.megatiles_array_decompressed[(Y/2)*64]
    ld     d,0
    ld     e,a                                           ; DE = X
    srl    e                                             ; DE = X/2
    add    hl,de                                         ; HL = &game.megatiles_array_decompressed[(Y/2)*64 + X/2]

    ; Calculate address in VRAM where we begin drawing.
    ; x_contribution = 2 * (x_tile mod 32);
    exx
    ld     bc,megatiles_corners                          ; BC' now contains megatiles_corners array start.
    bit    0,a                                           ; If we're on the right side of the megatile...
    jp     z,+
    ld     bc,megatiles_corners+1                        ; Get the right column info instead.
+:
    and    $1F
    rlca                                                 ; Offset into nametable is now in A
    ; y_contribution = zero, because we're drawing columns from the top of the nametable down.
    ld     h,VDPCommand_VRAMWriteByte|VRAM_NametableRAM_Highbyte
    ld     l,a                                           ; HL is now complete VDP Control command for directing writes into the nametable on the correct column from the top.
    exx                                                  ; Pointer to VRAM is stored in HL', megatiles_corners + optional 1 in BC'.

    ; The starting pointer is going to point to one of the elements on the top row of the name table.

    ld     b,28                                          ; B is counter for drawing tiles

ingame_tiles_draw_column_next_tile:

    ld     a,c                                           ; Inspect the discontinuity counter to see if we've reached the mid name-table split.
    and    a
    jp     nz,ingame_tiles_draw_column_next_tile_no_discontinuity
    ; We have run out of tiles on the vertical part of this run.
    ld     de,-14*64                                     ; Rewind the megatile reading cursor by 14 whole rows (this is a vertical screens worth of mega tiles)
    add    hl,de
ingame_tiles_draw_column_next_tile_no_discontinuity:
    dec    c

    ld     a,(hl)                                        ; Retrieve megatile value from array in A

    ; Now we need to know which corner we're referencing.
    ; Get the flag whether we are in the top-? or bottom-? corner into the FLAGS register.
    bit    0,b
    jp     z,+
    ld     de,64                                         ; If we're on an odd Y value, we should advance the megatile cursor by a row.
    add    hl,de
+:
    exx
    SetVDPAddress_af_prime                               ; Submit the VRAM write command from HL'
    ex     de,hl                                         ; Keep the VDP command safe while we use HL as a calculation destination.
    rlca                                                 ; Given that the megatile is going to be less than 128, save a handful of states by doubling it in A first.
    ld     h,0
    ld     l,a
    add    hl,hl                                         ; Calculate HL = megatile value * 4... HL is now the offset into megatiles_corners for information about the current megatile.
    add    hl,bc                                         ; HL = megatiles_corners[megatile_value * 4] + optional 1 for right column.
    jp     z,+
    inc    hl                                            ; If y is odd, then add two onto the megatile corner pointer
    inc    hl
+:  ld     a,(hl)                                        ; Retrieve real value of chip that goes in this corner of the megatile.

    ; A should contain the final tile number (0-255)
    out    (PORT_VDPData),a                              ; Write the low byte of the data. (Tile number bits 7-0)
    xor    a
    out    (PORT_VDPData),a                              ; Write the high byte of the data. (---pcvhn)
    ex     de,hl                                         ; Put the VDP command back in HL.
    ld     de,$40
    add    hl,de                                         ; Advance the destination pointer by the size of one row of tiles.
    exx
    djnz   ingame_tiles_draw_column_next_tile
    ret

; We need a subroutine to draw a horizontal row of game tiles to the nametable.
; We want to draw row (in 8x8 tiles) y=a, starting at x=b (must be a multiple of 32), drawing c tiles until looping.
ingame_tiles_draw_row:
    ; Calculate offset into megatiles array

    ; There are 64 megatiles across the GBMGX screen.
    ; We need to halve the Y coordinate first as we're thinking of megatiles.
    ld     h,0
    ld     l,a
    srl    l                                             ; HL = (Y/2)
    ; Multiply the Y/2 coordinate by 64 dec:
    add    hl,hl                                         ; HL = (Y/2)*2
    add    hl,hl                                         ; HL = (Y/2)*4
    add    hl,hl                                         ; HL = (Y/2)*8
    add    hl,hl                                         ; HL = (Y/2)*16
    add    hl,hl                                         ; HL = (Y/2)*32
    add    hl,hl                                         ; HL = (Y/2)*64
    ld     de,game.megatiles_array_decompressed
    add    hl,de                                         ; HL = &game.megatiles_array_decompressed[(Y/2)*64]
    ld     d,0
    ld     e,b                                           ; DE = X
    srl    e                                             ; DE = X/2
    add    hl,de                                         ; HL = &game.megatiles_array_decompressed[(Y/2)*64 + X/2]

    ; Calculate address in VRAM where we begin drawing.
    ; y_contribution = 2 * 32 * (y_tile mod 28);
    exx
    ld     de,megatiles_corners                          ; DE' now contains megatiles_corners array start.
    bit    0,a                                           ; If we're on the lower row of the megatile...
    jp     z,+
    ld     de,megatiles_corners+2                        ; Get the lower row info instead.
+:
-:  add    a,-28                                         ; Subtract 28 tentatively
    jp     p,-                                           ; Keep subtracting 28 until we go under
    add    a,28                                          ; A = y mod 28
    ld     h,0
    ld     l,a                                           ; HL' = 16 bit version of y mod 28
    add    hl,hl                                         ; HL' =  2*y
    add    hl,hl                                         ; HL' =  4*y
    add    hl,hl                                         ; HL' =  8*y
    add    hl,hl                                         ; HL' = 16*y
    add    hl,hl                                         ; HL' = 32*y
    add    hl,hl                                         ; HL' = 64*y
    ; x_contribution = zero, because we're drawing rows from the left of the nametable across.
    ld     bc,VDPCommand_VRAMWrite|VRAM_NametableRAM
    add    hl,bc                                         ; HL is now complete VDP Control command for directing writes into the nametable on the correct row on the left.
    SetVDPAddress_UNSAFE                                 ; Submit the VRAM write command.
    exx
                                                         ; megatiles_corners (with optional +2 for lower row) is in DE'

    ld     b,32                                          ; B is counter for drawing tiles

ingame_tiles_draw_row_next_tile:

    ld     a,c                                           ; Inspect the discontinuity counter to see if we've reached the mid name-table split.
    and    a
    jp     nz,ingame_tiles_draw_row_next_tile_no_discontinuity
    ; We have run out of tiles on the horizontal part of this run.
    ld     de,-16                                        ; Rewind the megatile reading cursor by 16 tiles.
    add    hl,de
ingame_tiles_draw_row_next_tile_no_discontinuity:
    dec    c                                             ; Decrement the discontinuity counter as we advance from left to right.

    ld     a,(hl)                                        ; Retrieve megatile value from array in A

    ; Now we need to know which corner we're referencing.
    ; Get the flag whether we are in the ?-left or ?-right corner into the FLAGS register.
    bit    0,b
    jp     z,+
    inc    hl                                            ; If we're on an odd X value, we should advance the megatile cursor by a row.
+:
    exx
    rlca                                                 ; Given that the megatile is going to be less than 128, save a handful of states by doubling it in A first.
    ld     h,0
    ld     l,a
    add    hl,hl                                         ; Calculate HL = megatile value * 4... HL is now the offset into megatiles_corners for information about the current megatile.
    add    hl,de                                         ; HL = megatiles_corners[megatile_value * 4] + optional 2 for lower row.
    jp     z,+
    inc    hl                                            ; If x is odd, then add one onto the megatile corner pointer
+:  ld     a,(hl)                                        ; Retrieve real value of chip that goes in this corner of the megatile.
    exx

    ; A should contain the final tile number (0-255)
    out    (PORT_VDPData),a                              ; Write the low byte of the data. (Tile number bits 7-0)
    xor    a
    out    (PORT_VDPData),a                              ; Write the high byte of the data. (---pcvhn)
    djnz   ingame_tiles_draw_row_next_tile
    ret

; Copy the correct greenwing frame from graphics_greenwing to the reserved tiles
; in VRAM, allowing us to change the sprite(s) we use for the greenwing player
; sprite in real time.
ingame_graphics_copy_greenwing_frame_to_vram:
    ; We're going to copy from data into tiles 512,513,514 and 515 of the VRAM pattern storage.
    ; This memory starts at $2000 in VRAM.
    ; Calculate the source pointer for greenwing pattern graphics data based on the current
    ; value of player_sprite_frame:

    ; The distance between successive Greenwing four-tile graphics data
    ; is 8+8+5+5 pixel rows, with 3 bytes per row = 78 bytes.
    ; That's a horrid number, by the way, so lets use our multiplication subroutine:
    ld     e,78
    ld     a,(game.player_sprite_frame)
    ld     h,a
    call   multiply_hl_equals_h_times_e
    ld     de,game.greenwing_sprite_decompressed_ram
    add    hl,de

    ; We want to output repeated rows of data, three bytes, then a zero. On row 21, we set the destination pointer to the final tile explicitly, leaving the bottom rows blank.

    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|$2000
    SetVDPAddress_de_UNSAFE
    ld     b,26                              ; 26 rows of data to copy.
ingame_graphics_copy_greenwing_frame_to_vram_next_pixel_row:
    ld     a,(hl)
    out    (PORT_VDPData),a                  ; Output the first bitplane of this pixel row
    inc    hl
    ld     a,(hl)
    out    (PORT_VDPData),a                  ; Output the second bitplane of this pixel row
    inc    hl
    ld     a,(hl)
    out    (PORT_VDPData),a                  ; Output the third bitplane of this pixel row
    inc    hl
    xor    a
    out    (PORT_VDPData),a                  ; Output the fourth bitplane of this pixel row, which is a constant zero.
    ld     a,b
    cp     6                                 ; When there are five rows remaining, we skip some pixel rows and set the destination VRAM ptr to the final tile.
    jp     nz,+
    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM|($2000+32*3)
    SetVDPAddress_de_UNSAFE
+:
    djnz   ingame_graphics_copy_greenwing_frame_to_vram_next_pixel_row

    ret
    
ingame_graphics_place_greenwing_sprite:
    ; Calculate the player's x position on screen.
    ; Use camera_x, which contains the final position of the camera.
    ld     hl,(game.player_position_x_pixels)                 ; We have the player X position in pixels in HL.
    ld     de,+8-9                                            ; Add on the 8 pixel X-masking shift, together with the X handle between the sprite corner and the player logical centre
    add    hl,de
    ld     de,(game.camera_x)
    xor    a                                                  ; Clear carry before sbc
    sbc    hl,de                                              ; Subtract the camera_x now (it's in pixels)
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+14*2  ; Place this into the appropriate memory location for Sprite 14
    SetVDPAddress_de_UNSAFE
    ld     a,l
    out    (PORT_VDPData),a                                   ; Output X position for Sprite 14
    ld     a,0                                                ; Select tile 256+0 for Sprite 14
    out    (PORT_VDPData),a                                   ; Output tile number for Sprite 14
    ld     a,l
    add    a,8                                                ; Advance to next sprite:
    out    (PORT_VDPData),a                                   ; Output X position for Sprite 15
    ld     a,1                                                ; Select tile 256+1 for Sprite 15
    out    (PORT_VDPData),a                                   ; Output tile number for Sprite 15
    ld     a,l
    out    (PORT_VDPData),a                                   ; Output X position for Sprite 16
    ld     a,2                                                ; Select tile 256+2 for Sprite 16
    out    (PORT_VDPData),a                                   ; Output tile number for Sprite 16
    ld     a,l
    add    a,8                                                ; Advance to next sprite:
    out    (PORT_VDPData),a                                   ; Output X position for Sprite 17
    ld     a,3                                                ; Select tile 256+3 for Sprite 17
    out    (PORT_VDPData),a                                   ; Output tile number for Sprite 17
    ; We should only have to put the player sprite pattern numbers into the table once, as they don't change
    ; but the alternative is to constantly keep setting the pointer just to skip them. That's expensive, so
    ; let's just keep OUTing 0,1,2,3 for the sprite numbers as we place the X values.

    ; Calculate the player's y position on screen.
    ; Use camera_y, which contains the final position of the camera.
    ld     hl,(game.player_position_y_pixels)                 ; We have the player Y position in pixels in HL.
    ld     de,-4                                              ; Add on the Y handle between the sprite corner and the player logical centre
    add    hl,de
    ld     de,(game.camera_y)
    sbc    hl,de                                              ; Subtract the camera_y now (it's in pixels)
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+14     ; Place this into the appropriate memory location for Sprite 14
    SetVDPAddress_de_UNSAFE
    ld     a,l                                                ; Place the Y position into the appropriate location
    dec    a                                                  ; Remember the sprites appear on the NEXT scanline, so decrement a.
    out    (PORT_VDPData),a                                   ; OUTPUT Y position for sprite 14
    nop                                                       ; I'm on to your tricks, sonny. I know about the VDP's timing requirements!
    out    (PORT_VDPData),a                                   ; OUTPUT Y position for sprite 15
    add    a,8
    out    (PORT_VDPData),a                                   ; OUTPUT Y position for sprite 16
    nop                                                       ; I'm on to your tricks, sonny. I know about the VDP's timing requirements!
    out    (PORT_VDPData),a                                   ; OUTPUT Y position for sprite 17

    ret

ingame_graphics_set_carrybox_sprite_palette:
    ; Copy one of two palettes to the sprite part of the CRAM based on
    ; whether the carrybox is in 196-255 or not.
    ld     de,VDPCommand_CRAMWrite|(16+4)                     ; This is the address of the four colours starting at the white in the sprite palette.
    SetVDPAddress_de_UNSAFE

    ld     a,(game.ingame_carrybox_flash_frame)
    add    a,48
    jp     nc,ingame_graphics_set_carrybox_sprite_palette_normal
ingame_graphics_set_carrybox_sprite_palette_white:
    ; Copy three whites
    ld     a,%00111111
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
    ret
ingame_graphics_set_carrybox_sprite_palette_normal:
    ; Copy three bytes from the palette data ingame palette
    ld     hl,palette_data_ingame+(16+4)
    ld     a,(hl)
    out    (PORT_VDPData),a
    inc    hl
    ld     a,(hl)
    out    (PORT_VDPData),a
    inc    hl
    ld     a,(hl)
    out    (PORT_VDPData),a
    ret

ingame_graphics_place_carrybox_sprite:
    ; Calculate the the box's x position on screen.
    ; Use camera_x, which contains the final position of the camera.
    ld     hl,(game.box_position_x_pixels)                    ; We have the box X position in pixels in HL.
    ld     de,8-5                                             ; Add on the 8 pixel X-masking shift, together with the X handle between the sprite corner and the box logical centre
    add    hl,de
    ld     de,(game.camera_x)
    sbc    hl,de                                              ; Subtract the camera_x now (it's in pixels)
    ; We have the final screen position of this sprite as a 16-bit signed integer in HL
    ld     b,h                                                ; Store value in BC
    ld     c,l
    ; It's time for some clipping calculations
    ld     de,0
    xor    a                                                  ; Reset carry
    adc    hl,de                                              ; Add on 0. If the result is negative, don't draw the box, it's off the left of the screen
    jp     m,ingame_graphics_hide_carrybox_sprite
    ld     h,b
    ld     l,c                                                ; Restore stored value from BC.
    ld     de,-256
    xor    a                                                  ; Reset carry
    adc    hl,de                                              ; Add on -256. If the result is positive, don't draw the box, it's off the right of the screen
    jp     p,ingame_graphics_hide_carrybox_sprite
    ; The X check has not resulted in the box not being drawn, so continue:
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+18*2  ; Place this into the appropriate memory location for Sprite 18
    SetVDPAddress_de_UNSAFE
    ld     a,c                                                ; Restore saved value from BC
    out    (PORT_VDPData),a                                   ; Output X position for Sprite 18
    ld     a,4                                                ; Select tile 256+4 for Sprite 18
    out    (PORT_VDPData),a                                   ; Output tile number for Sprite 18
    ld     a,c
    add    a,8                                                ; Advance to next sprite:
    out    (PORT_VDPData),a                                   ; Output X position for Sprite 19
    ld     a,5                                                ; Select tile 256+5 for Sprite 19
    out    (PORT_VDPData),a                                   ; Output tile number for Sprite 19

    ; Calculate the box's y position on screen.
    ; Use camera_y, which contains the final position of the camera.
    ld     hl,(game.box_position_y_pixels)                    ; We have the box Y position in pixels in HL.
    ld     de,-4                                              ; Add on the Y handle between the sprite corner and the box logical centre
    xor    a
    add    hl,de
    ld     de,(game.camera_y)
    sbc    hl,de                                              ; Subtract the camera_y now (it's in pixels)
    dec    hl                                                 ; Remember the sprites appear on the NEXT scanline, so decrement HL
    ld     b,h                                                ; Store value in BC
    ld     c,l
    ; It's time for some clipping calculations
    ld     de,8
    xor    a                                                  ; Reset carry
    adc    hl,de                                              ; Add on 8. If the result is negative, don't draw the box, it's off the top of the screen
    jp     m,ingame_graphics_hide_carrybox_sprite
    ld     h,b
    ld     l,c                                                ; Restore stored value from BC.
    ld     de,-192
    xor    a                                                  ; Reset carry
    adc    hl,de                                              ; Add on -192. If the result is positive, don't draw the box, it's off the bottom of the screen
    jp     p,ingame_graphics_hide_carrybox_sprite
    ; The X check has not resulted in the box not being drawn, so continue:
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+18     ; Place this into the appropriate memory location for Sprite 18
    SetVDPAddress_de_UNSAFE
    ld     a,c                                                ; Place the Y position into the appropriate location
    out    (PORT_VDPData),a                                   ; OUTPUT Y position for sprite 18
    nop                                                       ; I'm on to your tricks, sonny. I know about the VDP's timing requirements!
    out    (PORT_VDPData),a                                   ; OUTPUT Y position for sprite 19
    ret
ingame_graphics_hide_carrybox_sprite:
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+18     ; Place off-screen values into sprites 18 and 19.
    SetVDPAddress_de_UNSAFE
    ld     a,200                                              ; Offscreen y
    out    (PORT_VDPData),a                                   ; Sprite 18 y value
    nop                                                       ; I'm on to your tricks, sonny. I know about the VDP's timing requirements!
    out    (PORT_VDPData),a                                   ; Sprite 19 y value
    ret

; The linkage sprites are sprites 20, 21 and 22
ingame_graphics_place_linkage_sprites:
    ; Determine whether or not the linkage is active.
    ; Hide the sprites if the linkage is not currently active.
    ld     a,(game.player_link_established)
    cp     0
    jp     z,ingame_graphics_hide_linkage_sprites

    ; Place X positions and tile numbers into the appropriate memory location for Sprite 20
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+20*2
    SetVDPAddress_de_UNSAFE

    ld     hl,(game.box_position_x)
    ld     de,(game.player_position_x)
    xor    a                                                  ; Clear carry before sbc.
    sbc    hl,de                                              ; We have the offset between the player and the box in HL
    sra    h
    rr     l
    sra    h
    rr     l                                                  ; Divide this by 4
    sra    h
    rr     l
    sra    h
    rr     l                                                  ; Divide it some more to put it into 14.2
    ld     b,h
    ld     c,l                                                ; We are now storing the X distance between linkage sprites in fixed point 14.2 in BC
    ; Calculate the player's x position on screen.
    ; Use camera_x, which contains the final position of the camera.
    ld     hl,(game.player_position_x_pixels)                 ; We have the player X position in pixels in HL.
    ld     de,(game.camera_x)
    xor    a                                                  ; Clear carry before sbc.
    sbc    hl,de                                              ; Subtract the camera_x now (it's in pixels)
    ld     de,8-1                                             ; Add on the eight pixels for the hidden column and subtract one pixel for handle of the sprite
    add    hl,de
    ; HL contains the position of the (linkage sprite that would be placed at the) player center on screen in pixels.
    add    hl,hl
    add    hl,hl                                              ; Promote this to 14.2 fixed point
    ld     d,h
    ld     e,l                                                ; Store this in DE. This is the position of the first linkage sprite in 14.2
    add    hl,bc                                              ; Add on the linkage contribution
    sra    h
    rr     l
    sra    h
    rr     l                                                  ; Return the value to pixels
    ld     a,l
    out    (PORT_VDPData),a                                   ; Output X position for Sprite 20
    ld     a,6                                                ; Select tile 256+6 for Sprite 20
    out    (PORT_VDPData),a                                   ; Output tile number for Sprite 20
    ld     h,d
    ld     l,e                                                ; Retrieve the player's position on screen into HL.
    add    hl,bc                                              ; Add on the linkage contribution
    add    hl,bc                                              ; Add on the linkage contribution (* 2)
    sra    h
    rr     l
    sra    h
    rr     l                                                  ; Return the value to pixels
    ld     a,l
    out    (PORT_VDPData),a                                   ; Output X position for Sprite 21
    ld     a,6                                                ; Select tile 256+6 for Sprite 21
    out    (PORT_VDPData),a                                   ; Output tile number for Sprite 21
    ld     h,d
    ld     l,e                                                ; Store this in DE.
    add    hl,bc                                              ; Add on the linkage contribution
    add    hl,bc                                              ; Add on the linkage contribution
    add    hl,bc                                              ; Add on the linkage contribution (* 3)
    sra    h
    rr     l
    sra    h
    rr     l                                                  ; Return the value to pixels
    ld     a,l
    out    (PORT_VDPData),a                                   ; Output X position for Sprite 22
    ld     a,6                                                ; Select tile 256+6 for Sprite 22
    out    (PORT_VDPData),a                                   ; Output tile number for Sprite 22
    
    ; Place Y positions and tile numbers into the appropriate memory location for Sprite 20
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+20
    SetVDPAddress_de_UNSAFE

    ld     hl,(game.box_position_y)
    ld     de,(game.player_position_y)
    xor    a                                                  ; Clear carry before sbc.
    sbc    hl,de                                              ; We have the offset between the player and the box in HL
    sra    h
    rr     l
    sra    h
    rr     l                                                  ; Divide this by 4
    sra    h
    rr     l
    sra    h
    rr     l                                                  ; Divide it some more to put it into 14.2
    ld     b,h
    ld     c,l                                                ; We are now storing the Y distance between linkage sprites in fixed point 14.2 in BC
    ; Calculate the player's y position on screen.
    ; Use camera_y, which contains the final position of the camera.
    ld     hl,(game.player_position_y_pixels)                 ; We have the player Y position in pixels in HL.
    ld     de,(game.camera_y)
    sbc    hl,de                                              ; Subtract the camera_y now (it's in pixels)
    dec    l                                                  ; The handle into the linkage sprite means we draw it one pixel to the top of this position.
    dec    l                                                  ; Subtract one because the sprites are drawn on the next scanline.
    ; HL contains the position of the (linkage sprite that would be placed at the) player center on screen in pixels.
    add    hl,hl
    add    hl,hl                                              ; Promote this to 14.2 fixed point
    ld     d,h
    ld     e,l                                                ; Store this in DE. This is the position of the first linkage sprite in 14.2
    add    hl,bc                                              ; Add on the linkage contribution
    sra    h
    rr     l
    sra    h
    rr     l                                                  ; Return the value to pixels
    ld     a,l
    out    (PORT_VDPData),a                                   ; Output Y position for Sprite 20
    ld     h,d
    ld     l,e                                                ; Store this in DE.
    add    hl,bc                                              ; Add on the linkage contribution
    add    hl,bc                                              ; Add on the linkage contribution (* 2)
    sra    h
    rr     l
    sra    h
    rr     l                                                  ; Return the value to pixels
    ld     a,l
    out    (PORT_VDPData),a                                   ; Output Y position for Sprite 21
    ld     h,d
    ld     l,e                                                ; Store this in DE.
    add    hl,bc                                              ; Add on the linkage contribution
    add    hl,bc                                              ; Add on the linkage contribution
    add    hl,bc                                              ; Add on the linkage contribution (* 3)
    sra    h
    rr     l
    sra    h
    rr     l                                                  ; Return the value to pixels
    ld     a,l
    out    (PORT_VDPData),a                                   ; Output Y position for Sprite 22

    ret
ingame_graphics_hide_linkage_sprites:
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+20     ; Place off-screen values into sprites 20 21 22.
    SetVDPAddress_de_UNSAFE
    ld     a,200                                              ; Offscreen y
    out    (PORT_VDPData),a                                   ; Sprite 6 y value
    nop                                                       ; I'm on to your tricks, sonny. I know about the VDP's timing requirements!
    out    (PORT_VDPData),a                                   ; Sprite 7 y value
    nop                                                       ; I'm on to your tricks, sonny. I know about the VDP's timing requirements!
    out    (PORT_VDPData),a                                   ; Sprite 8 y value
    ret

; The position of the sprite timer on screen.
.equ INGAME_BOMBLED_X_LEFT = 110
.equ INGAME_BOMBLED_Y_TOP  = 4

; Bombled sprites are 0 through 13
ingame_graphics_place_bombled_sprites:

    ; Place X positions and tile numbers into the appropriate memory location for Sprite 0 onwards:
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+0*2
    SetVDPAddress_de_UNSAFE

    ld     d,0

    ld     b,INGAME_BOMBLED_X_LEFT
    ld     a,(game_persistent.ingame_bombled_minutes_counter)
    ld     e,a
    call   ingame_graphics_place_a_bombled_sprite_xn
    ld     b,INGAME_BOMBLED_X_LEFT+13
    ld     a,(game_persistent.ingame_bombled_seconds_counter_h)
    ld     e,a
    call   ingame_graphics_place_a_bombled_sprite_xn
    ld     b,INGAME_BOMBLED_X_LEFT+21
    ld     a,(game_persistent.ingame_bombled_seconds_counter_l)
    ld     e,a
    call   ingame_graphics_place_a_bombled_sprite_xn
    ld     b,INGAME_BOMBLED_X_LEFT+34
    ld     a,(game_persistent.ingame_bombled_hundredths_counter_h)
    ld     e,a
    call   ingame_graphics_place_a_bombled_sprite_xn
    ld     b,INGAME_BOMBLED_X_LEFT+42
    ld     a,(game_persistent.ingame_bombled_hundredths_counter_l)
    ld     e,a
    call   ingame_graphics_place_a_bombled_sprite_xn
    
    ; Place the flashing colons at a specific x position.
    ld     a,INGAME_BOMBLED_X_LEFT+8
    out    (PORT_VDPData),a
    ld     a,20
    out    (PORT_VDPData),a
    ld     a,INGAME_BOMBLED_X_LEFT+8
    out    (PORT_VDPData),a
    ld     a,20
    out    (PORT_VDPData),a
    ld     a,INGAME_BOMBLED_X_LEFT+29
    out    (PORT_VDPData),a
    ld     a,20
    out    (PORT_VDPData),a
    ld     a,INGAME_BOMBLED_X_LEFT+29
    out    (PORT_VDPData),a
    ld     a,20
    out    (PORT_VDPData),a
    ; We'll do the logic for blinking in the Y position down here.

    ; Place Y positions into the appropriate memory location for Sprite 0 onwards:
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+0
    SetVDPAddress_de_UNSAFE

    ld     b,5
-:  ld     a,INGAME_BOMBLED_Y_TOP
    out    (PORT_VDPData),a                                   ; Output Y position for topmost Sprite
    ld     a,INGAME_BOMBLED_Y_TOP+8
    out    (PORT_VDPData),a                                   ; Output Y position for bottom-most Sprite
    djnz   -
    
    ld     a,(game_persistent.ingame_bombled_hundredths_counter_h)
    cp     5
    jp     m,+
    ld     a,INGAME_BOMBLED_Y_TOP-1
    out    (PORT_VDPData),a
    ld     a,INGAME_BOMBLED_Y_TOP+5
    out    (PORT_VDPData),a
    ld     a,INGAME_BOMBLED_Y_TOP-1
    out    (PORT_VDPData),a
    ld     a,INGAME_BOMBLED_Y_TOP+5
    out    (PORT_VDPData),a
    ret
+:  ld     a,240                                              ; For hundredths number 49 and below, hide the colons.
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a
    nop
    out    (PORT_VDPData),a


    ret

; The position of the sprite timer on screen.
.equ WIN_BOMBLED_X_LEFT = 148
.equ WIN_BOMBLED_Y_TOP  = 59

; Bombled sprites are 0 through 13
win_graphics_place_bombled_sprites:

    ; Place X positions and tile numbers into the appropriate memory location for Sprite 0 onwards:
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_XN_RAM+0*2
    SetVDPAddress_de_UNSAFE

    ld     d,0

    ld     b,WIN_BOMBLED_X_LEFT
    ld     a,(game_persistent.ingame_bombled_minutes_counter)
    ld     e,a
    call   ingame_graphics_place_a_bombled_sprite_xn
    ld     b,WIN_BOMBLED_X_LEFT+13
    ld     a,(game_persistent.ingame_bombled_seconds_counter_h)
    ld     e,a
    call   ingame_graphics_place_a_bombled_sprite_xn
    ld     b,WIN_BOMBLED_X_LEFT+21
    ld     a,(game_persistent.ingame_bombled_seconds_counter_l)
    ld     e,a
    call   ingame_graphics_place_a_bombled_sprite_xn
    ld     b,WIN_BOMBLED_X_LEFT+34
    ld     a,(game_persistent.ingame_bombled_hundredths_counter_h)
    ld     e,a
    call   ingame_graphics_place_a_bombled_sprite_xn
    ld     b,WIN_BOMBLED_X_LEFT+42
    ld     a,(game_persistent.ingame_bombled_hundredths_counter_l)
    ld     e,a
    call   ingame_graphics_place_a_bombled_sprite_xn
    
    ; Place the flashing colons at a specific x position.
    ld     a,WIN_BOMBLED_X_LEFT+8
    out    (PORT_VDPData),a
    ld     a,20
    out    (PORT_VDPData),a
    ld     a,WIN_BOMBLED_X_LEFT+8
    out    (PORT_VDPData),a
    ld     a,20
    out    (PORT_VDPData),a
    ld     a,WIN_BOMBLED_X_LEFT+29
    out    (PORT_VDPData),a
    ld     a,20
    out    (PORT_VDPData),a
    ld     a,WIN_BOMBLED_X_LEFT+29
    out    (PORT_VDPData),a
    ld     a,20
    out    (PORT_VDPData),a

    ; Place Y positions into the appropriate memory location for Sprite 0 onwards:
    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM+0
    SetVDPAddress_de_UNSAFE

    ld     b,5
-:  ld     a,WIN_BOMBLED_Y_TOP
    out    (PORT_VDPData),a                                   ; Output Y position for topmost Sprite
    ld     a,WIN_BOMBLED_Y_TOP+8
    out    (PORT_VDPData),a                                   ; Output Y position for bottom-most Sprite
    djnz   -

    ld     a,WIN_BOMBLED_Y_TOP-1
    out    (PORT_VDPData),a
    ld     a,WIN_BOMBLED_Y_TOP+5
    out    (PORT_VDPData),a
    ld     a,WIN_BOMBLED_Y_TOP-1
    out    (PORT_VDPData),a
    ld     a,WIN_BOMBLED_Y_TOP+5
    out    (PORT_VDPData),a
    ret

ingame_graphics_place_a_bombled_sprite_xn:
    ; At X position B, put the digit de
    ld     a,b
    out    (PORT_VDPData),a                                   ; Output X position for Sprite
    ld     hl,bombled_tile_top_table
    add    hl,de                                              ; Retrieve the indicated digit.
    ld     a,(hl)
    add    a,7
    out    (PORT_VDPData),a                                   ; Select tile 256+7+digit for Sprite
    ld     a,b
    out    (PORT_VDPData),a                                   ; Output X position for Sprite
    ld     hl,bombled_tile_bottom_table
    add    hl,de                                              ; Retrieve the indicated digit.
    ld     a,(hl)
    add    a,7
    out    (PORT_VDPData),a                                   ; Select tile 256+8+digit for Sprite

    ret

; What tile should be used for the top of the given digit?
bombled_tile_top_table:
.db 0,1,2,2,3,4,4,5,6,6
; What tile should be used for the bottom of the given digit?
bombled_tile_bottom_table:
.db 7,8,9,10,11,10,12,8,12,10

ingame_forces_calculation:
    ; Spring force calculation is really difficult!

.equ FORCES_CALCULATION_ROPE_MAX_LENGTH         = 100                ; Disengage link if box is this far away from ship in pixels.
.equ FORCES_CALCULATION_ROPE_MAX_LENGTH_SQUARED = FORCES_CALCULATION_ROPE_MAX_LENGTH*FORCES_CALCULATION_ROPE_MAX_LENGTH
.equ FORCES_CALCULATION_ROPE_MIN_LENGTH         =  17                ; The beam has no attractive effect below this distance in pixels.
.equ FORCES_CALCULATION_ROPE_MIN_LENGTH_SQUARED = FORCES_CALCULATION_ROPE_MIN_LENGTH*FORCES_CALCULATION_ROPE_MIN_LENGTH

    ; Calculate the spring force:
    
    ; The aim of this routine is as follows: given the current state of the game, in the 
    ; player_link_established, player_position_x/y_pixels and box_position_x/y_pixels
    ; variables, use the formula dvx = dx * K *(s/d) to calculate the base change in velocity
    ; for this single frame due to the elastic nature of the gravity beam.
    ; s is the stretch of the beam: this is the distance between the player and the box minus the minimum active length of the beam.
    ; d is the distance between the player and the box.
    ; Together, the ratio of these is known as as the 'stretch ratio' in my code
    ; K is a constant (the 'spring constant' in the literature) expressing the strength of the spring.
    ; K is implicit in the calculations (it appears when all the sra/rr stuff happens right at the end
    ; in order to convert the fixed point stretch ratio into a useable velocity value.)
    ; dx is the distance between the player and the box in a given cartesian direction.

    ; The calculated base contribution to the velocity should be stored in the variables
    ; ingame_forces_calculation_vdx and ingame_forces_calculation_vdy.
    ; If the rope is slack or the beam becomes disengaged these values should take the default value of zero.
    ld     hl,0
    ld     (game.ingame_forces_calculation_vdx),hl
    ld     (game.ingame_forces_calculation_vdy),hl

    ld     a,(game.player_link_established)
    cp     0
    jp     z,ingame_forces_calculation_player_isnt_connected ; Don't calculate forces if the player isn't connected!
ingame_forces_calculation_begins:
    ld     bc,FORCES_CALCULATION_ROPE_MAX_LENGTH
    ; Calculate DX in pixels:
    ld     hl,(game.box_position_x_pixels)
    ld     de,(game.player_position_x_pixels)
    xor    a
    sbc    hl,de                                             ; HL contains 'dx' box-player in pixels 1.15.0
    ld     (game.ingame_forces_calculation_dx_pixels),hl
    xor    a
    sbc    hl,bc                                             ; HL = dx - max_length. If this is greater than zero, the box is way too far to the right of the player.
    jp     p,ingame_forces_calculation_dx_out_of_range_disengage_beam
    ld     hl,(game.ingame_forces_calculation_dx_pixels)
    xor    a
    adc    hl,bc                                             ; HL = dx + max_length. If this is negative, the box is way too far to the left of the player
    jp     m,ingame_forces_calculation_dx_out_of_range_disengage_beam
    ; The beam is not going to be disengaged due to dx being beyond the maximum length of the rope.
    ; Calculate DY in pixels:
    ld     hl,(game.box_position_y_pixels)
    ld     de,(game.player_position_y_pixels)
    xor    a
    sbc    hl,de                                             ; HL contains 'dy' box-player in pixels 1.15.0
    ld     (game.ingame_forces_calculation_dy_pixels),hl
    xor    a
    sbc    hl,bc                                             ; HL = dy - max_length. If this is greater than zero, the box is way too far to the down of the player.
    jp     p,ingame_forces_calculation_dy_out_of_range_disengage_beam
    ld     hl,(game.ingame_forces_calculation_dy_pixels)
    xor    a
    adc    hl,bc                                             ; HL = dy + max_length. If this is negative, the box is way too far to the up of the player
    jp     m,ingame_forces_calculation_dy_out_of_range_disengage_beam
    ; The beam is not going to be disengaged due to dy being beyond the maximum length of the rope.
    ; Now we need to calculate the squared length of the rope:
    ; dx^2 = dx*dx
    ld     a,(game.ingame_forces_calculation_dx_pixels)      ; Given that this value is within the range -128,127, we can use the lowest byte only.
    call   multiply_hl_equals_a_times_a                      ; HL = dx^2
    ld     b,h
    ld     c,l                                               ; Store dx^2 in BC.
    ld     a,(game.ingame_forces_calculation_dy_pixels)      ; Given that this value is within the range -128,127, we can use the lowest byte only.
    call   multiply_hl_equals_a_times_a                      ; HL = dy^2
    add    hl,bc                                             ; d^2 = dx^2 + dy^2
    ; We now have d^2 in HL.
    ld     b,h
    ld     c,l                                               ; Store d^2 in BC.
    ld     de,-FORCES_CALCULATION_ROPE_MAX_LENGTH_SQUARED
    xor    a
    adc    hl,de                                             ; If this is positive, the box is outside the squared range.
    jp     p,ingame_forces_calculation_d_out_of_range_disengage_beam
    ld     de,FORCES_CALCULATION_ROPE_MIN_LENGTH_SQUARED
    ld     h,b
    ld     l,c                                               ; Retrieve d^2 from BC.
    xor    a
    sbc    hl,de                                             ; If this is negative, the box is within the 'no effect' zone of the beam.
    jp     m,ingame_forces_calculation_complete
    ld     h,b
    ld     l,c                                               ; Retrieve d^2 from BC.
    call   sqrt_hl_into_a                                    ; We now have the length of the beam in A.
    ld     c,a                                               ; Store d in C (in pixels)
    sub    FORCES_CALCULATION_ROPE_MIN_LENGTH                ; We now have the 'stretch' of the beam in A.
    ld     h,a
    ld     l,0                                               ; HL is now 16 bit stretch of beam in 8.8 format.
    call   divide_hl_equals_hl_over_c_remainder_a            ; HL contains stretch/length ratio in 8.8 format.
;    ld     (ingame_forces_calculation_vdy2),hl
    srl    h                                                 ; Ditch some precision!
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    srl    h
    rr     l
    ; We should incorporate the Ks constant at this point by doing something with this ratio.
    ld     b,h
    ld     c,l
    ld     de,(game.ingame_forces_calculation_dx_pixels)
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    call   multiply_dehl_equals_bc_times_de
    ld     (game.ingame_forces_calculation_vdx),hl
    ld     de,(game.ingame_forces_calculation_dy_pixels)
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    sra    d
    rr     e
    call   multiply_dehl_equals_bc_times_de
    ld     (game.ingame_forces_calculation_vdy),hl

    jp     ingame_forces_calculation_complete

ingame_forces_calculation_dx_out_of_range_disengage_beam:
ingame_forces_calculation_dy_out_of_range_disengage_beam:
ingame_forces_calculation_d_out_of_range_disengage_beam:
    xor    a
    ld     (game.player_link_established),a                  ; Simply set the link established variable to off.
    ; Play the brels theme...
;    ld     hl,music_gravity_beam_panic
;    call   music_select_song
;    call   music_resume
    ; Use my neat 'boousssh' sound effect to register a beam snap.
    ld     c,0
    call   sound_force
    jp     ingame_forces_calculation_complete

ingame_forces_calculation_player_isnt_connected:
ingame_forces_calculation_rope_is_slack:
ingame_forces_calculation_complete:
    ret

; Clears the entire contents of the VRAM to zeroes.
vram_clear_all:

    ld     de,VDPCommand_VRAMWrite|VRAM_PatternRAM
    SetVDPAddress_de_UNSAFE

    ld     bc,1024*16                ; Counter for 16KB of VRAM
-:  xor    a                         ; Write zeroes:
    out    (PORT_VDPData),a          ; Output to VRAM address, which is auto-incremented after each write
    dec    bc
    ld     a,b                       ; Load b into a (b is most significant byte of bc)
    or     c                         ; a = b|c   OR instruction sets flags!
    jp     nz,-

    ret

; Places all the sprites offscreen
vram_hide_all_sprites:

    ld     de,VDPCommand_VRAMWrite|VRAM_SpriteAT_Y_RAM
    SetVDPAddress_de_UNSAFE

    ld     b,64
    ld     a,200
-:  out    (PORT_VDPData),a          ; Put all sprites offscreen.
    djnz   -

    ret

vdp_set_registers_screen_mode_ingame:
    ; Set up VDP registers for the ingame screen mode.
    ; This means setting up the 8 pixel overlay, and the SMS screen mode
    ; no doubled/tall sprites, and set the sprite source to use 2nd 256 set
    ; of patterns from the chipset.
    ld     hl,vdp_registers_screen_mode_ingame
    ld     b,vdp_registers_screen_mode_ingame_end-vdp_registers_screen_mode_ingame ; Copy this many bytes.
-:  ld     a,(hl)
    inc    hl
    out    (PORT_VDPControl),a
    djnz   -

    ret

.ends ; End of code section

.struct game_persistent_variables_struct

; These variables persist outside the game and into the win cinematic, allowing us
; to query the game timer after teh games RAM has been clobbered
ingame_bombled_minutes_counter        db
ingame_bombled_seconds_counter_h      db
ingame_bombled_seconds_counter_l      db
ingame_bombled_hundredths_counter_h   db
ingame_bombled_hundredths_counter_l   db

controls_inverted                     db

thrust_button_mask                    db
beam_button_mask                      db

.endst

.struct game_variables_struct
game_paused                           db

; These are the FINAL camera top-left position in pixels
camera_x                              dw
camera_y                              dw

; These are the previous frame camera top-left position in pixels
camera_old_x                          dw
camera_old_y                          dw

; These are the camera 'wants to be' top-left position in pixels
camera_focus_x                        dw
camera_focus_y                        dw

; These contain the X and Y value of the top and leftmost edge of tiles
; we update these whenever we draw a new row/column, and use them to
; determine whether the most recent camera shift has triggered more tiles
; to be drawn.
tiles_row_y                           db
tiles_column_x                        db

player_orientation                    db

player_sprite_frame                   db

; Position in 12.4, velocity in 1.7.8
player_position_x                     dw
player_position_y                     dw
player_position_x_pixels              dw ; These are indicative, rather than controlling. We calculate the resultant pixel location whenever we
player_position_y_pixels              dw ; change the fixed point version so we don't have to recalc it in each routine that wants to use it.
player_velocity_x                     dw
player_velocity_y                     dw

box_position_x                        dw
box_position_y                        dw
box_position_x_pixels                 dw ; These are indicative, rather than controlling. We calculate the resultant pixel location whenever we
box_position_y_pixels                 dw ; change the fixed point version so we don't have to recalc it in each routine that wants to use it.
box_velocity_x                        dw
box_velocity_y                        dw

player_link_established               db

ingame_carrybox_flash_frame           db

; Unsigned 16-bit value
ingame_carrybox_remaining_health      dw

; These are temporarily variables used when calculating the spring force
ingame_forces_calculation_dx_pixels   dw
ingame_forces_calculation_dy_pixels   dw

ingame_forces_calculation_vdx         dw    ; Base contribution to velocity change from spring force.
ingame_forces_calculation_vdy         dw

; These are the values that should be put into the scroll registers. Note that a 'zero' camera x becomes an 8 scroll due to the masking of the left column.
scroll_register_x                     db
scroll_register_y                     db

; This counter is used to control the fade out (to white or black)
; depending on the type of screen we're transitioning to from 'ingame'.
anim_frame_counter                    db

; OH GOD MATT WHY.
greenwing_sprite_decompressed_ram     dsb ha1_graphics_greenwing_bin_fullsize
megatiles_array_decompressed          dsb ha1_levellayout_megatiles_bin_fullsize
.endst

.struct win_cinematic_variables_struct

anim_frame_counter                    db
anim_frame_counter2                   dw ; Second frame counter used for complex scenes where we fade, and have extra control things going on simultaneously.

win_cinematic_stage_number            db ; There are a number of distinct stages to the win cinematic, we count the major stage here

win_cinematic_frame_counter           db ; Within a major stage, we put the frame counter here.

win_cinematic_gw_x                    db ; Where does the big greenwing appear on screen.
win_cinematic_gw_y                    db ; Where does the big greenwing appear on screen.

win_cinematic_crate_x                 db ; Where does the big crate appear on screen.
win_cinematic_crate_y                 db ; Where does the big crate appear on screen.

win_cinematic_upper_sprite_at_y       dsb  64
win_cinematic_upper_sprite_at_xn      dsb 128

win_cinematic_lower_sprite_at_y       dsb  64
win_cinematic_lower_sprite_at_xn      dsb 128

.endst

.struct plot_1_variables_struct

anim_frame_counter                     db
anim_frame_counter2                    dw

alert_frame_counter                    db
alert_frame_counter2                   dw

; These are the values that should be put into the scroll registers. Note that a 'zero' camera x becomes an 8 scroll due to the masking of the left column.
alert_scroll_register_x                db

; Copy logo outside of screen blank/unblank time to reduce flicker. Use this flag to say 'when'.
copy_nuclear_logo_flag                 db

graphics_radioactive_2bpp_decompressed dsb ha1_graphics_plot_1_radioactive_2bpp_bin_fullsize

.endst

.struct plot_2_variables_struct

anim_frame_counter                    db
anim_frame_counter2                   dw

stars_anim_frame_counter              db

; Clear text between pages outside of screen blank/unblank time to reduce flicker. Use this flag to say 'when'.
clear_text_on_page_switch_flag        db

.endst

.struct lose_variables_struct

anim_frame_counter                    db
anim_frame_counter2                   dw

; These are the values that should be put into the scroll registers. Note that a 'zero' camera x becomes an 8 scroll due to the masking of the left column.
scroll_register_x                     db

graphics_contactlosttiles_2bpp_decompressed dsb ha1_graphics_contactlosttiles_2bpp_bin_fullsize

.endst

.struct title_variables_struct

anim_frame_counter                    db
anim_frame_counter2                   dw

greenwing_x                           db
greenwing_y                           db

pressed_start                         db
menu_cursor_position                  db

.endst

; Declare variables by granting them space within the RAMSECTION, which I've
; called "variables". SLOT 1 refers to the RAM slot we declared in .memorymap
; in segamastersystem.z80asm
.RAMSECTION "variables" SLOT 1

; The way this works: we have a bunch of variables that are common to all the different
; screens, and we have a giant union that holds a bunch of different structures

greenfont_base_tile_number                    dw ; When the green font is loaded into VRAM, we can load it into an arbitrary tile number
                                                 ; Storing the tile number use chose here assists the font writing routine!

vram_greenfont_charplace_tile_cursor_x_start  db ; The tile number where the cursor should return when we hit a newline.
vram_greenfont_charplace_tile_cursor_x        db ; The position within the nametable where the next character should be drawn
vram_greenfont_charplace_tile_cursor_y        db

vram_greenfont_charplace_string_ptr           dw ; Pointer to the next character should be printed

game_persistent                               instanceof game_persistent_variables_struct

; Union begins here. Does WLADX support anything of the sort? It would be nice if it did.
; Until it does, all of these are going to have to simply be sequential until I can make
; them coincident.
plot_1                                        instanceof plot_1_variables_struct
plot_2                                        instanceof plot_2_variables_struct
title                                         instanceof title_variables_struct
game                                          instanceof game_variables_struct
win_cinematic                                 instanceof win_cinematic_variables_struct
lose                                          instanceof lose_variables_struct

.ends ; End of ram section

.bank 0
.section "!music_assets" ; Exclamation mark means 'never optimise away this section if not referred to'

music_plot_1:
.incbin "musicmodule_plot_1.bin"
music_plot_2:
.incbin "musicmodule_plot_2.bin"
music_gravity_beam_panic:
.incbin "musicmodule_ingame.bin"
music_fanfare:
.incbin "musicmodule_fanfare.bin"
music_explosionbeep:
.incbin "musicmodule_explosionbeep.bin"

.ends

.bank 0
.section "!sine_table" ; Exclamation mark means 'never optimise away this section if not referred to'

; An array of 128 sine values, a full cycle. 16-bit signed, with range [$003B, $FFC5]. (59, -59 dec).
; Used for thrust calculation (these are direct contributions to player velocity.)
thrust_sine_table:
.incbin "sine_table.bin"

.ends

.bank 0
.section "!graphics_assets" ; Exclamation mark means 'never optimise away this section if not referred to'

; graphics_gaiden_ingame_tiles.bin contains pattern data for 204 8x8 tiles.

; The greenfont tiles are a list of 80 tiles, 2bpp. Use bitwise math to put the bits back into the appropriate bitplanes!!
graphics_greenfont:
.incbin "graphics_greenfont_2bpp.bin"
graphics_greenfont_end:

; Contains all the frames for the greenwing.
; The top left and top right tiles are complete.
; The bottom left and bottom right tiles are missing their bottom three rows
; And for every four-byte bitplaned row of eight pixels, I've omitted the final
; high byte (all of the colours are in the range 0-7). Have fun reinflating that!
;graphics_greenwing:
; This has moved and is now Huffman Nibble Compressed (TM)
;.incbin "graphics_greenwing.bin"

; The carrybox is two 8x8 tiles of vram pattern data, followed by two more rows for the linkage. There's no compression because it's 64+8 bytes big anyway!!
graphics_carrybox:
.incbin "graphics_carrybox.bin"

; The bombleds are a strip of 14 tiles, 4bpp
;graphics_bombleds:
;.incbin "graphics_bombleds.bin"
; This has been moved to the huffman compressed archive 1

; The contact lost tiles are a list of 22 tiles, 2bpp
;graphics_contactlosttiles:
;.incbin "graphics_contactlosttiles_2bpp.bin" now huffman compressed

; 2bpp tiles for the large count in numbers when the level begins ingame.
graphics_count_in_digits_2bpp:
.incbin "graphics_count_in_digits_2bpp.bin"
graphics_count_in_digits_2bpp_end:

; Space ending background tiles, 2bpp
graphics_ending_space_tiles:
.incbin "graphics_ending_spacetiles_2bpp.bin"
graphics_ending_space_tiles_end:

; Crate ending sprites, 4bpp.
;graphics_ending_crate_sprites:
;.incbin "graphics_ending_crate_twoframes.bin"
;graphics_ending_crate_sprites_end:
; This has been moved to the huffman compressed archive 1

; List of indices into the huffman archive 1 greenwing huffman compressed tiles to allow me to draw the sprites!
graphics_ending_greenwingsprites_map:
.incbin "graphics_ending_greenwingsprites_map.bin"

; Gravity beam logo tiles. 2bpp.
graphics_title_gravitybeamlogo:
.incbin "graphics_title_gravitybeamlogotiles.bin"
graphics_title_gravitybeamlogo_end:

; List of indices into the above tiles (23 x 8)
graphics_title_gravitybeamlogo_map:
.incbin "graphics_title_gravitybeamlogotiles_map.bin"

; 2bpp MASTERGIDN letters tile reduced.
graphics_master_gaiden_letters_2bpp:
.incbin "graphics_master_gaiden_letters_2bpp.bin"
graphics_master_gaiden_letters_2bpp_end:

; Radioactive logo 2bpp.
;graphics_plot_1_radioactive_2bpp:
;.incbin "graphics_plot_1_radioactive_2bpp.bin"
; List of indices into the radioactive logo
graphics_plot_1_radioactive_2bpp_map:
.incbin "graphics_plot_1_radioactive_2bpp_map.bin"

.ends

.bank 0
.section "!levels_assets" ; Exclamation mark means 'never optimise away this section if not referred to'

; This is an 64 across by 48 down array of Megatiles describing the layout of the GBMG level.
;megatiles_array:
;.incbin "levellayout_megatiles.bin"
; This has been moved to the huffman compressed archive 1

; This is an array of [4byte] structures indicating what 8x8 tiles should be placed
; into the nametable for the given Megatile.
megatiles_corners:  ; Top left, top right, bottom left, bottom right.
.include "megatiles_definitions.z80asm"

palette_data_ingame:
; Tilemap palette
.db %00010001
.db %00000011
.db %00001111
.db %00001011
.db %00001010
.db %00111110
.db %00111010
.db %00000000
.db %00000001
.db %00000101
.db %00000110
.db %00111111
.db %00000000
.db %00000000
.db %00000000
.db %00000000
; Sprite palette
.db %00000000
.db %00000000
.db %00001000
.db %00001100
.db %00111111  ; palette entry 16 + 4 here are the blue colours for the crate.
.db %00111000
.db %00100100
.db %00000011  ; red for thrust.
.db %00000010  ; red for bombleds
.db %00000000  ; Colour 9 onwards for greenfont ingame
.db %00000100
.db %00001100
.db %00000000
.db %00000000
.db %00000000
.db %00000000
palette_data_ingame_end:
palette_data_lose_static:
; Tilemap palette
.db %00000000
.db %00000000
.db %00010101
.db %00010101
.db %00101010
.db %00101010
.db %00111111
.db %00111111
.db %00000000
.db %00000011
.db %00000010
.db %00001000
.db %00001100
.db %00000000
.db %00000000
.db %00000000
; Colour 17 is the overscan colour
.db %00000000
palette_data_lose_static_end:

palette_data_win_cinematic:
; Tilemap palette
.db %00010000
.db %00100010
.db %00101010
.db %00111111
.db %00010000
.db %00100010
.db %00101010
.db %00111111
.db %00000000
.db %00100010
.db %00101010
.db %00000100
.db %00001100
.db %00100010
.db %00101010
.db %00111111
palette_data_win_cinematic_sprite_palette:
; Sprite palette
.db %00000000
.db %00000000
.db %00000100
.db %00001000
.db %00001100
.db %00111111
.db %00101111
.db %00011011
.db %00000011
.db %00100000
.db %00110001
.db %00111001
.db %00111010
.db %00000000
.db %00000000
.db %00000000
palette_data_win_cinematic_end:
palette_data_win_cinematic_sprite_palette_engine_alt:  ; flickering engine palette.
; Sprite palette
.db %00000000
.db %00000000
.db %00000100
.db %00001000
.db %00001100
.db %00111111
.db %00011010
.db %00001010
.db %00000010
.db %00100000
.db %00110001
.db %00111001
.db %00111010
.db %00000000
.db %00000000
.db %00000000
palette_data_win_cinematic_sprite_palette_engine_alt_end:

palette_data_win_cinematic_explode_alt:                               ; exploding universe crate palette.
; Tilemap palette
.db %00010000
.db %00100010
.db %00101010
.db %00111111
.db %00010000
.db %00100010
.db %00101010
.db %00111111
.db %00010000
.db %00100010
.db %00101010
.db %00111111
.db %00010000
.db %00100010
.db %00101010
.db %00111111
palette_data_win_cinematic_sprite_palette_explode_alt:
; Sprite palette
.db %00000000
.db %00000011
.db %00000100
.db %00001000
.db %00001100
.db %00111111
.db %00011010
.db %00011010
.db %00000010
.db %00101111
.db %00111111
.db %00111111
.db %00011111
.db %00000000
.db %00000000
.db %00000000
palette_data_win_cinematic_sprite_palette_explode_alt_end:

; VDP initialisation data
; Initialise the registers by outing these byte pairs to port VDPControl
vdp_registers_screen_mode_ingame:
; Data in First Byte, %1000rrrr is the Second Byte of a VDP register write command. %10000000 indicates a Register Write.
.db %00100100,%10000000 | $0
.db %11100000,%10000000 | $1
.db %11111111,%10000000 | $2
.db %11111111,%10000000 | $3
.db %11111111,%10000000 | $4 ; The background nametable data is based at $3800
.db %11111111,%10000000 | $5 ; Sprite attribute table is based at $3F00
.db %11111111,%10000000 | $6 ; Set bit 2 of register 6 to cause sprite data to be fetched from the second set of 256 tiles.
.db %11110000,%10000000 | $7 ; Overscan colour. It's taken from the sprite palette. I'm picking colour zero, which is never visible otherwise.... right?
.db %00000000,%10000000 | $8 ; Background X scroll
.db %00000000,%10000000 | $9 ; Background Y scroll
.db %11111111,%10000000 | $a
vdp_registers_screen_mode_ingame_end:

vdp_registers_blank_screen:
    ld     a,%10100000
    out    (PORT_VDPControl),a
    ld     a,1|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
    ret

vdp_registers_unblank_screen:
    ld     a,%11100000
    out    (PORT_VDPControl),a
    nop
    nop
    ld     a,1|VDPCommand_RegWriteByte
    out    (PORT_VDPControl),a
    ret

palette_data_title:
; Tilemap palette
.db %00000000
.db %00011111
.db %00000110
.db %00001011
.db %00111111
.db %00010101
.db %00100000
.db %00000010
.db %00000000
.db %00001000
.db %00010000
.db %00001010
.db %00001111
.db %00000010
.db %00000000
.db %00000000
; Sprite palette
.db %00000000
.db %00000000
.db %00000100
.db %00001000
.db %00001100
.db %00111111
.db %00101111
.db %00011011
.db %00000011
.db %00100000
.db %00110001
.db %00111001
.db %00111010
.db %00000000
.db %00000000
.db %00000000
palette_data_title_end:

palette_data_plot_1: ; This is the palette we initially fade to.
; Tilemap palette
.db %00000000
.db %00001010
.db %00001111
.db %00001000
;.db %00000001
;.db %00000001   ; Do I want the red strip across the screen?
;.db %00000001
;.db %00000001
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00100000
.db %00110001
.db %00001000
.db %00001100
.db %00000001
.db %00000011
.db %00000010
palette_data_plot_1_nuclear:
; Sprite palette
.db %00000000
.db %00001010
.db %00001111
.db %00001000
.db %00000000
.db %00001010
.db %00001111
.db %00001000
.db %00000000
.db %00100000
.db %00110001
.db %00001000
.db %00001100
.db %00000000
.db %00000000
.db %00000000
palette_data_plot_1_nuclear_red:
; Sprite palette
.db %00000000
.db %00001010
.db %00001111
.db %00001000
.db %00000000
.db %00000010
.db %00000011
.db %00001000
.db %00000000
.db %00100000
.db %00110001
.db %00001000
.db %00001100
.db %00000000
.db %00000000
.db %00000000
palette_data_plot_1_end:
; When we copy the red nuclear palette to CRAM during plot_1
; we copy 32 colours. The 1st colour in the sprite palette is the overlay
; colour, so lets make sure it's BLACK. (This fixes the bug where the
; overlay would turn blue when the nuke symbol turns red. This was because
; the first colour in the palette below was the %00010000 blue in the
; background of the ship cinematic window.)
.db %00000000

palette_data_plot_2:
; Tilemap palette
.db %00010000
.db %00000000
.db %00000100
.db %00001000
.db %00001100
.db %00111111
.db %00101111
.db %00011011
.db %00000011
.db %00100000
.db %00110001
.db %00111001
.db %00111010
.db %00000000
.db %00000000
.db %00000000
palette_data_plot_2_sprite_palette:
; Sprite palette
.db %00000000
.db %00000000
.db %00000100
.db %00001000
.db %00001100
.db %00111111
.db %00101111
.db %00011011
.db %00000011
.db %00100000
.db %00110001
.db %00111001
.db %00111010
.db %00000000
.db %00000000
.db %00000000
palette_data_plot_2_end:

palette_data_plot_2_alternate: ; Engine flickering again
; Tilemap palette
.db %00010000
.db %00000000
.db %00000100
.db %00001000
.db %00001100
.db %00111111
.db %00011010
.db %00001010
.db %00000010
.db %00100000
.db %00110001
.db %00111001
.db %00111010
.db %00000000
.db %00000000
.db %00000000
palette_data_plot_2_alternate_sprite_palette:
; Sprite palette
.db %00000000
.db %00000000
.db %00000100
.db %00001000
.db %00001100
.db %00111111
.db %00101111
.db %00011011
.db %00000011
.db %00100000
.db %00110001
.db %00111001
.db %00111010
.db %00000000
.db %00000000
.db %00000000
palette_data_plot_2_alternate_end:

.ends

